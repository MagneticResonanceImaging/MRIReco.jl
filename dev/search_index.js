var documenterSearchIndex = {"docs":
[{"location":"acquisitionData/#Acquisition-Data","page":"Acquisition Data","title":"Acquisition Data","text":"","category":"section"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"There are two different forms of acquisition data types in MRIReco:","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"RawAcquisitionData\nAcquisitionData","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"While the former is used to hold the data in the form, how it will be written out from the scanner, the later has already performed some data permutations bringing the data into the shape how the reconstruction expects it.","category":"page"},{"location":"acquisitionData/#Raw-Data","page":"Acquisition Data","title":"Raw Data","text":"","category":"section"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"The RawAcquisitionData is a data type that closely resembles the ISMRMRD data format. It looks like","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"mutable struct RawAcquisitionData\n  params::Dict{String, Any}\n  profiles::Vector{Profile}\nend","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"with","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"mutable struct Profile\n  head::AcquisitionHeader\n  traj::Array{Float32,2}\n  data::Array{Complex{Float32},2}\nend","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"The params member of RawAcquisitionData is basically the a flattened dictionary derived from the XML part of an ISMRMRD file. A Profile describes the data measured after a single excitation during an MRI experiment. It has members head, traj, and data, which exactly resemble the structures specified by the ISMRMRD file format.","category":"page"},{"location":"acquisitionData/#Preprocessed-Data","page":"Acquisition Data","title":"Preprocessed Data","text":"","category":"section"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"The RawAcquisitionData can be preprocessed into a form, which makes it more convenient for reconstruction algorithms. The AcquisitionData type looks like","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"mutable struct AcquisitionData\n  sequenceInfo::Dict{Symbol,Any}\n  traj::Vector{Trajectory}\n  kdata::Array{Matrix{ComplexF64},3}\n  subsampleIndices::Vector{Array{Int64}}\n  encodingSize::Vector{Int64}\n  fov::Vector{Float64}\nend","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"It consists of the sequence informations stored in a dictionary, the k-space trajectory, the k-space data, and several parameters describing the dimension of the data and some additional index vectors.","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"The k-space data kdata has three dimensions encoding","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"dim : contrasts/echoes\ndim : slices\ndim : repetitions","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"Each element is a matrix encoding","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"dim : k-space nodes\ndim : channels/coils","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"In case of undersampled data, the subsampling indices are stored in subsampleIndices. One check if the data is undersampled by checking if isempty(subsampleIndices).","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"The encoded space is stored in the field encodingSize. It is especially relevant for non-Cartesian trajectories where it is not clear upfront, how large the grid size for reconstruction should be chosen. Finally fov describes the physical lengths of the encoding grid.","category":"page"},{"location":"trajectories/#Trajectory","page":"Trajectory","title":"Trajectory","text":"","category":"section"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"Several typical MRI k-space trajectories are available:","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"Cartesian\nEPI\nRadial\nSpiral","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"In addition, it is also possible to define new k-space trajectories. Currently, most of the trajectories are only available in 2D. Each trajectory is of type Trajectory and implements the following functions","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"string(tr::Trajectory)\nkspaceNodes(tr::Trajectory)\nreadoutTimes(tr::Trajectory)","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"For instance we can define a spiral, radial, and cartesian trajectory using","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"tr = trajectory(\"Spiral\", 1, 600, windings=10)\ntr = trajectory(\"Cartesian\", 13, 50, EPI_factor=1)\ntr = trajectory(\"Radial\", 13, 50)","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"A variable density spiral can be generated by","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"tr = trajectory(\"SpiralVarDens\", 3, 200)","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"The k-space nodes can then be accessed by","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"nodes = kspaceNodes(tr)","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"The script generating the following image can be executed by running the following from within the Julia REPL:","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"include(joinpath(dirname(pathof(MRIReco)),\"../docs/src/examples/exampleTrajectories.jl\"))","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"(Image: Trajectories)","category":"page"},{"location":"compressedSensing/#Compressed-Sensing","page":"Compressed Sensing","title":"Compressed Sensing","text":"","category":"section"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"We next consider a compressed sensing reconstruction using one slice of a knee dataset obtained from mridata.org. The example can be run by entering","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"include(joinpath(dirname(pathof(MRIReco)),\"../docs/src/examples/exampleCS.jl\"))","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"into the Julia REPL.","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"We first perform a baseline reconstruction with fully sampled data:","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"# load fully sampled data\nf = ISMRMRDFile(\"data/knee_3dFSE_slice170.h5\")\nacqData = AcquisitionData(f);\n\n# reconstruct\nparams = Dict{Symbol, Any}()\nparams[:reco] = \"direct\"\nparams[:reconSize] = (320,320) # this size is also contained in acqData.encodingSize\n\nimg = reconstruction(acqData, params)\nimg = sqrt.(sum(img.^2,dims=5))","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"The result looks like this:","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"(Image: Knee Original)","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"To simulate an undersampled reconstruction, we retrospectively undersample the data using a Poisson disk pattern.","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"redFac = 4.0\nacqDataSub = sample_kspace(acqData,redFac,\"poisson\",calsize=30,profiles=false);","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"The sampling pattern looks like this:","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"(Image: Mask)","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"Then, we estimate the coil sensitivities using ESPIRiT","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"smaps = espirit(acqData,(6,6),30,eigThresh_1=0.035,eigThresh_2=0.98)","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"and perform a simple SENSE reconstruction. We expect a degradation in image quality due to the subsampling:","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"params = Dict{Symbol, Any}()\nparams[:reco] = \"multiCoil\"\nparams[:reconSize] = (320,320)\nparams[:senseMaps] = smaps\n\nparams[:solver] = \"cgnr\"\nparams[:regularization] = \"L2\"\nparams[:λ] = 1.e-4\nparams[:iterations] = 5\nparams[:normalizeReg] = true\n\nimg_cg = reconstruction(acqDataSub, params)","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"Using TV regularization recquires us to change some parameters:","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"params = Dict{Symbol, Any}()\nparams[:reco] = \"multiCoil\"\nparams[:reconSize] = (320,320)\nparams[:senseMaps] = smaps\n\nparams[:solver] = \"admm\"\nparams[:regularization] = \"TV\"\nparams[:λ] = 1.e-1 # 5.e-2\nparams[:iterations] = 50\nparams[:ρ] = 0.1\nparams[:absTol] = 1.e-4\nparams[:relTol] = 1.e-2\nparams[:tolInner] = 1.e-2\nparams[:normalizeReg] = true\n\nimg_tv = reconstruction(acqDataSub, params)","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"Lets compare the results, left the regular SENSE reconstruction and right the TV reglarized solution:","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"(Image: SENSE) (Image: TV)","category":"page"},{"location":"image/#Images","page":"Images","title":"Images","text":"","category":"section"},{"location":"image/","page":"Images","title":"Images","text":"All reconstructed data is stored as an AxisArray. The AxisArrays package is part of the Images package family, which groups all image processing related functionality together. We note that the term Image does not restrict the dimensionality of the data types to 2D but in fact images can be of arbitrary dimensionality.","category":"page"},{"location":"image/","page":"Images","title":"Images","text":"The reconstructed MRI image I is an AxisArray and has five dimensions. The first three are the spatial dimension x, y, and z, whereas dimension four encodes the number of echos that have been reconstructed, while dimension five encodes individual coils that may have been reconstructed independently. By using an AxisArray the object does not only consist of the data but it additionally encodes the physical size of the image as well as the echo times. To extract the ordinary Julia array one can simply use Ireco.data.","category":"page"},{"location":"image/","page":"Images","title":"Images","text":"The advantage of encoding the physical dimensions is the image data can be stored without loosing the dimensions of the data. For instance one can call","category":"page"},{"location":"image/","page":"Images","title":"Images","text":"saveImage(filename, I)","category":"page"},{"location":"image/","page":"Images","title":"Images","text":"to store the image and","category":"page"},{"location":"image/","page":"Images","title":"Images","text":"I = loadImage(filename)","category":"page"},{"location":"image/","page":"Images","title":"Images","text":"to load the image. Currently, MRIReco does support the NIfTI file format. By default, saveImage stores the data complex valued if the image I is complex valued. To store the magnitude image one can call","category":"page"},{"location":"image/","page":"Images","title":"Images","text":"saveImage(filename, I, true)","category":"page"},{"location":"offresonance/#Offresonance-Correction","page":"Offresonance","title":"Offresonance Correction","text":"","category":"section"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"For trajectories with long readouts the MRI images are degraded by offresonance artifacts, if the offresonance is not taken into account during reconstruction. We provide fast algorithms that are capable of correcting offresonance artifacts provided that the offresonance map is known. Our framework is also capable of correcting T2* relaxation effects. The later are encoded in the real part of the correction map while the offresoanance is encoded in the imaginary part. The following example shows an example of a simulation and reconstruction of MRI data that takes offresonance due to an inhomogeneous fieldmap into account. The example can be run by entering","category":"page"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"include(joinpath(dirname(pathof(MRIReco)),\"../docs/src/examples/exampleFieldmap.jl\"))","category":"page"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"into the Julia REPL.","category":"page"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"using MRIReco\n\nN = 256\nI = shepp_logan(N)\nI = circularShutterFreq!(I,1)\ncmap = 1im*quadraticFieldmap(N,N,125*2pi)\n\n# simulation parameters\nparams = Dict{Symbol, Any}()\nparams[:simulation] = \"fast\"\nparams[:trajName] = \"Spiral\"\nparams[:numProfiles] = 1\nparams[:numSamplingPerProfile] = N*N\nparams[:windings] = 128\nparams[:AQ] = 3.0e-2\nparams[:correctionMap] = cmap[:,:,1]\n\n# do simulation\nacqData = simulation(I, params)\n\n# reco parameters\nparams = Dict{Symbol, Any}()\nparams[:reco] = \"direct\"\nparams[:reconSize] = (N,N)\nparams[:correctionMap] = cmap\nparams[:alpha] = 1.75\nparams[:m] = 4.0\nparams[:K] = 28\n\n# do reconstruction\nIreco = reconstruction(acqData, params)","category":"page"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"The considered quadratic fieldmap looks like this:","category":"page"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"(Image: Fieldmap)","category":"page"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"The reconstruction without and with offresonance correction are shown below:","category":"page"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"(Image: NoCorrection) (Image: Reconstruction)","category":"page"},{"location":"custom/#Customization","page":"Customize","title":"Customization","text":"","category":"section"},{"location":"custom/","page":"Customize","title":"Customize","text":"We promised that MRIReco allows for customization. Lets in the following consider a custom data-driven sparsifying transform that is currently not part of MRIReco.jl [S. Ravishankar and Y. Bresler, IEEE Trans. Med. Imaging, 30 (5), 2011].","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"It is based on","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"Learn a dictionary from a reference image (e.g. adjacent slice) using KSVD  colorgreencheckmark\nImplement sparsifying transform which analyses the input image in terms of the dictionary","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"(Image: DictTrafo)","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"In order to implement this, we first need the analyze function where we can reuse the matchingpursuit function from Wavelets.jl","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"function analyzeImage(x::Vector{T},D::Matrix{T},xsize::NTuple{2,Int64},\n                      psize::NTuple{2,Int64};t0::Int64=size(D,2),tol=1e-3) where T\n  nx,ny = xsize\n  px,py = psize\n  x = reshape(x,nx,ny)\n  x_pad = repeat(x,2,2)[1:nx+px-1,1:ny+py-1] # pad image using periodic boundary conditions\n  α = zeros(T,size(D,2),nx,ny)\n  patch = zeros(T,px*py)\n  for j=1:ny\n    for i=1:nx\n      patch[:] .= vec(x_pad[i:i+px-1,j:j+py-1])\n      norm(patch)==0 && continue\n      # matchingpursuit is contained in Wavelets.jl\n      α[:,i,j] .= matchingpursuit(patch, x->D*x, x->transpose(D)*x, tol)\n    end\n  end\n  return vec(α)\nend","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"Synthetization can be done by","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"function synthesizeImage(α::Vector{T},D::Matrix{T},xsize::NTuple{2,Int64},psize::NTuple{2,Int64}) where T\n  nx,ny = xsize\n  px,py = psize\n  x = zeros(T,nx+px-1,ny+py-1)\n  α = reshape(α,:,nx,ny)\n  for j=1:ny\n    for i=1:nx\n      x[i:i+px-1,j:j+py-1] .+= reshape(D*α[:,i,j],px,py)\n    end\n  end\n  return vec(x[1:nx,1:ny])/(px*py)\nend","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"Once we have those two operations we can setup up a dictionary operator:","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"function dictOp(D::Matrix{T},xsize::NTuple{2,Int64},psize::NTuple{2,Int64},tol::Float64=1.e-3) where T\n  produ = x->analyzeImage(x,D,xsize,psize,tol=tol)\n  ctprodu = x->synthesizeImage(x,D,xsize,psize)\n  return LinearOperator(prod(xsize)*size(D,2),prod(xsize),false,false\n          , produ\n          , nothing\n          , ctprodu )\nend","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"To test our method, let us load some simulated data and subsample it","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"# phantom\nimg = readdlm(\"data/mribrain100.tsv\")\n\nacqData = AcquisitionData(ISMRMRDFile(\"data/acqDataBrainSim100.h5\"))\nnx,ny = acqData.encodingSize\n\n# undersample kspace data\nacqData = sample_kspace(acqData, 2.0, \"poisson\", calsize=25,profiles=false);","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"Now we load a pre-trained dictionary, build the sparsifying transform and perform the reconstruction","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"# load the dictionary\nD = ComplexF64.(readdlm(\"data/brainDict98.tsv\"))\n\n# some parameters\npx, py = (6,6)  # patch size\nK = px*py       # number of atoms\n\n# CS reconstruction using Wavelets\nparams = Dict{Symbol,Any}()\nparams[:reco] = \"standard\"\nparams[:reconSize] = (nx,ny)\nparams[:iterations] = 50\nparams[:λ] = 2.e-2\nparams[:regularization] = \"L1\"\nparams[:sparseTrafo] = dictOp(D,(nx,ny),(px,py),2.e-2)\nparams[:ρ] = 0.1\nparams[:solver] = \"admm\"\nparams[:absTol] = 1.e-4\nparams[:relTol] = 1.e-2\n\nimg_d = reconstruction(acqData,params)","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"For comparison, let us perform the same reconstruction as above but with a Wavelet transform","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"delete!(params, :sparseTrafo)\nparams[:sparseTrafoName] = \"Wavelet\"\n\nimg_w = reconstruction(acqData,params)","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"The following pictures shows the wavelet based CS reconstruction on the left and the dictionary based CS reconstruction on the right:","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"(Image: BrainWavelet) (Image: BrainDict)","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"For reference, the original data is shown here:","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"(Image: BrainOrig)","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"One can clearly see that the dictionary approach performs better than a simple Wavelet L1 prior.","category":"page"},{"location":"gettingStarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"Throughout the entire documentation we assume that you have loaded MRIReco as well as PyPlot via","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"using PyPlot, MRIReco","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"Its important to load these packages in that order, since otherwise PyPlot will not work correctly on some systems.","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"All examples discussed in the documentation can be found in the package source code in the folder","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"    MRIReco/docs/src/examples","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"This folder is located in ~/.julia/packages or ~/.julia/dev depending if you have checked out MRIReco for development or not. You can call the first example by entering into the Julia REPL:","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"include(joinpath(dirname(pathof(MRIReco)),\"../docs/src/examples/exampleRadial.jl\"))","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"which should open a plotting window as is outlined in the following example.","category":"page"},{"location":"gettingStarted/#Basic-Example","page":"Getting Started","title":"Basic Example","text":"","category":"section"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"We will start with a very simple example and perform simple simulation and reconstruction based on a shepp logan phantom. The program looks like this","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"# image\nN = 256\nI = shepp_logan(N)\n\n# simulation parameters\nparams = Dict{Symbol, Any}()\nparams[:simulation] = \"fast\"\nparams[:trajName] = \"Radial\"\nparams[:numProfiles] = floor(Int64, pi/2*N)\nparams[:numSamplingPerProfile] = 2*N\n\n# do simulation\nacqData = simulation(I, params)\n\n# reco parameters\nparams = Dict{Symbol, Any}()\nparams[:reco] = \"direct\"\nparams[:reconSize] = (N,N)\nIreco = reconstruction(acqData, params)","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"We will go through the program step by step. First we create a 2D shepp logan phantom of size N=256. Then we setup a dictionary that defines the simulation parameters. Here, we chose a simple radial trajectory with 402 spokes and 512 samples per profile. We use a gridding-based simulator by setting params[:simulation] = \"fast\"","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"After setting up the parameter dictionary params, the simulation is performed by calling","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"acqData = simulation(I, params)","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"The result simulation function outputs an acquisition object that is discussed in more detail in the section Acquisition Data. The acquisition data can also be stored to or loaded from a file, which will be discussed in section File Handling.","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"Using the acquisition data we can perform a reconstruction. To this end, again a parameter dictionary is setup and some basic configuration is done. In this case, for instance we specify that we want to apply a simple NFFT-based gridding reconstruction. The reconstruction is invoked by calling","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"Ireco = reconstruction(acqData, params)","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"The resulting image is of type AxisArray and has 5 dimensions. One can display the image object by calling","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"imshow(abs.(Ireco[:,:,1,1,1]))","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"Alternatively one can store the image into a file, which will be discussed in the section on Images.","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"The original phantom and the reconstructed image are shown below","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: Phantom) (Image: Reconstruction)","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"We will discuss reconstruction in more detail in the sections on Offresonance Correction, Parallel Imaging, and Compressed Sensing","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"This page contains documentation of the public API of MRIReco. In the Julia REPL one can access this documentation by entering the help mode with ? and then writing the function for which the documentation should be shown.","category":"page"},{"location":"API/#Operators","page":"API","title":"Operators","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Operators are implemented as subtypes of AbstractLinearOperator, which is defined in the package LinearOperators.jl. Such operators must provide a function implementing the product and a function implementing the product with the adjoint. Furthermore, the number of rows and columns of the operator must be specified.","category":"page"},{"location":"API/","page":"API","title":"API","text":"MRIReco.encodingOps2d_simple\nMRIReco.encodingOps3d_simple\nMRIReco.encodingOps2d_parallel\nMRIReco.encodingOps3d_parallel\nMRIReco.encodingOp2d_multiEcho\nMRIReco.encodingOp3d_multiEcho\nMRIReco.encodingOp2d_multiEcho_parallel\nMRIReco.encodingOp3d_multiEcho_parallel\nMRIReco.fourierEncodingOp2d\nMRIReco.fourierEncodingOp3d\nMRIReco.ExplicitOp(shape::NTuple{D,Int64}, tr::Trajectory, correctionmap::Array{ComplexF64,D}; MRIReco.echoImage::Bool=false, kargs...) where D\nRegularizedLeastSquares.FFTOp(T::Type, shape::Tuple, shift=true)\nMRIReco.NFFTOp(shape::Tuple, tr::Trajectory; nodes=nothing, kargs...)\nMRIReco.FieldmapNFFTOp(shape::NTuple{D,Int64}, tr::Trajectory,\n                        correctionmap::Array{ComplexF64,D};\n                        method::String=\"nfft\",\n                        echoImage::Bool=true,\n                        alpha::Float64=1.75,\n                        m::Float64=3.0,\n                        K=20,\n                        kargs...) where D\nMRIReco.SamplingOp\nMRIReco.SensitivityOp\nMRIReco.SparseOp\nMRIReco.RegularizedLeastSquares.WeightingOp","category":"page"},{"location":"API/#MRIReco.ExplicitOp-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, Trajectory, Array{ComplexF64, D}}} where D","page":"API","title":"MRIReco.ExplicitOp","text":"ExplicitOp(shape::NTuple{D,Int64}, tr::Trajectory, correctionmap::Array{ComplexF64,D}\n        ; echoImage::Bool=false, kargs...) where D\n\ngenerates a ExplicitOp which explicitely evaluates the MRI Fourier signal encoding operator.\n\nArguments:\n\nshape::NTuple{D,Int64}             - size of image to encode/reconstruct\ntr::Trajectory                     - Trajectory with the kspace nodes to sample\ncorrectionmap::Array{ComplexF64,D} - fieldmap for the correction of off-resonance effects\nechoImage::Bool=false              - if true sampling times will only be considered relative to the echo time                                        this results in complex valued image even for real-valued input.\nkargs                              - additional keyword arguments\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.FieldmapNFFTOp-Union{Tuple{D}, Tuple{Tuple{Vararg{Int64, D}}, Trajectory, Array{ComplexF64, D}}} where D","page":"API","title":"MRIReco.FieldmapNFFTOp","text":"FieldmapNFFTOp(shape::NTuple{D,Int64}, tr::Trajectory,\n                    correctionmap::Array{ComplexF64,D};\n                    method::String=\"nfft\",\n                    echoImage::Bool=true,\n                    alpha::Float64=1.75,\n                    m::Float64=3.0,\n                    K=20,\n                    kargs...) where D\n\ngenerates a FieldmapNFFTOp which evaluates the MRI Fourier signal encoding operator, including B0-inhomogeneities using time-segmented NFFTs.\n\nArguments:\n\nshape::NTuple{D,Int64}             - size of image to encode/reconstruct\ntr::Trajectory                     - Trajectory with the kspace nodes to sample\ncorrectionmap::Array{ComplexF64,D} - fieldmap for the correction of off-resonance effects\n(method::String=\"nfft\")            - method to use for time-segmentation when correctio field inhomogeneities\n(echoImage::Bool=false)            - if true sampling times will only be considered relative to the echo time                                        this results in complex valued image even for real-valued input.\n(alpha::Float64=1.75)              - oversampling factor for interpolation\n(m::Float64=3.0)                   - truncation size of interpolation kernel\n(K=20)                             - number of translates for LeastSquares approaches                                        (not NFFT-approach) to time-segmentation\n(kargs)                            - additional keyword arguments\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.SamplingOp","page":"API","title":"MRIReco.SamplingOp","text":"SamplingOp(pattern::Array{Int}, shape::Tuple)\n\nbuildsa LinearOperator which only returns the vector elements at positions indicated by pattern.\n\nArguents\n\npattern::Array{Int} - indices to sample\nshape::Tuple        - size of the array to sample\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.SensitivityOp","page":"API","title":"MRIReco.SensitivityOp","text":"SensitivityOp(sensMaps::Matrix{ComplexF64}, numEchoes::Int=1)\n\nbuilds a LinearOperator which performs multiplication of a given image with the coil sensitivities specified in sensMaps\n\nArguments\n\nsensMaps::Matrix{ComplexF64}  - sensitivity maps ( 1. dim -> voxels, 2. dim-> coils)\nnumEchoes                     - number of contrasts to which the opetaor will be applied\n\n\n\n\n\nSensitivityOp(sensMaps::Array{T,4}, numContr::Int=1) where T\n\nbuilds a LinearOperator which performs multiplication of a given image with the coil sensitivities specified in sensMaps\n\nArguments\n\nsensMaps::Array{T,4}  - sensitivity maps ( 1.-3. dim -> voxels, 4. dim-> coils)\nnumContr             - number of contrasts to which the opetaor will be applied\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.SparseOp","page":"API","title":"MRIReco.SparseOp","text":"SparseOp(name::AbstractString, shape::NTuple{N,Int64}; kargs...) where N\n\ngenerates the sparsifying transform (<: AbstractLinearOperator) given its name.\n\nArguments\n\nname::AbstractString    - name of the sparsifying transform\nshape::NTuple{N,Int64}  - size of the Array to be transformed\n(kargs)                 - additional keyword arguments\n\n\n\n\n\n","category":"function"},{"location":"API/#Datatypes","page":"API","title":"Datatypes","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"MRIReco.AcquisitionData\nMRIReco.AcquisitionData(tr::T,kdata::Array{Matrix{ComplexF64},3}\n                        ; seqInfo=Dict{Symbol,Any}()\n                        , idx=nothing\n                        , encodingSize=Int64[0,0,0]\n                        , fov=Float64[0,0,0]\n                        , kargs...) where T <: Union{Trajectory,Vector{Trajectory}}\nMRIReco.trajectory(acqData::AcquisitionData,i::Int64=1)\nMRIReco.numContrasts(acqData::AcquisitionData)\nMRIReco.numChannels\nMRIReco.numSlices\nMRIReco.numRepetitions\nMRIReco.kData\nMRIReco.multiEchoData\nMRIReco.multiCoilData\nMRIReco.multiCoilMultiEchoData\nMRIReco.profileData\nMRIReco.samplingDensity\nMRIReco.changeEncodingSize2D\nMRIReco.convert3dTo2d\nMRIReco.RawAcquisitionData\nMRIReco.trajectory(f::RawAcquisitionData; slice::Int=1, contrast::Int=1)\nMRIReco.rawdata(f::RawAcquisitionData)\nMRIReco.AcquisitionData(f::RawAcquisitionData)\nMRIReco.RawAcquisitionData(f::ISMRMRDFile, dataset=\"dataset\")\nMRIReco.AcquisitionData(f::ISMRMRDFile, dataset=\"dataset\")","category":"page"},{"location":"API/#MRIReco.AcquisitionData","page":"API","title":"MRIReco.AcquisitionData","text":"struct describing MRI acquisition data.\n\nFields\n\nsequenceInfo::Dict{Symbol,Any}          - additional information on the pulse sequence\ntraj::Vector{Trajectory}                - trajectories for each echo/contrast\nkdata::Array{Matrix{ComplexF64},3}      - each matrix contains data for one trajectory                                             (1. dim k-space nodes, 2. dim coils)                                             the outer dims describe:                                             1. dim echoes, 2. dim slices, 3. dim repetitions\nsubsampleIndices::Vector{Array{Int64}}  - indices sampled for each echo/contrast\nencodingSize::Vector{Int64}             - size of the underlying image matrix\nfov::Vector{Float64}                    - field of view in m\n\n\n\n\n\n","category":"type"},{"location":"API/#MRIReco.AcquisitionData-Union{Tuple{T}, Tuple{T, Array{Matrix{ComplexF64}, 3}}} where T<:Union{Trajectory, Vector{Trajectory}}","page":"API","title":"MRIReco.AcquisitionData","text":"AcquisitionData(tr::T,kdata::Array{Matrix{ComplexF64},3}; seqInfo=Dict{Symbol,Any}()\n                    , idx=nothing, encodingSize=Int64[0,0,0], fov=Float64[0,0,0]\n                    , kargs...) where T <: Union{Trajectory,Vector{Trajectory}}\n\nconstructor for AcquisitionData\n\nArguments\n\ntr <: Union{Trajectory,Vector{Trajectory}} - trajectories\nkdata::Array{Matrix{ComplexF64},3}         - k-space data\n\nthe other fields of AcquisitionData can be passed as keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.trajectory","page":"API","title":"MRIReco.trajectory","text":"trajectory(acqData::AcquisitionData,i::Int64=1)\n\nreturns the i-th trajectory contained in acqData.\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.numContrasts-Tuple{AcquisitionData}","page":"API","title":"MRIReco.numContrasts","text":"numContrasts(acqData::AcquisitionData)\n\nreturns the number of contrasts/echoes in acqData\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.numChannels","page":"API","title":"MRIReco.numChannels","text":"numChannels(acqData::AcquisitionData)\n\nreturns the number of channels/coils in acqData\n\n\n\n\n\nnumChannels(f::RawAcquisitionData)\n\nreturns the number of channels in a RawAcquisitionData object.\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.numSlices","page":"API","title":"MRIReco.numSlices","text":"numSlices(tr::Trajectory) returns the number of slices of a trajectory \n\n\n\n\n\nnumSlices(acqData::AcquisitionData)\n\nreturns the number of slices in acqData\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.numRepetitions","page":"API","title":"MRIReco.numRepetitions","text":"numRepetitions(acqData::AcquisitionData)\n\nreturns the number of repetitions in acqData\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.kData","page":"API","title":"MRIReco.kData","text":"kData(acqData::AcquisitionData, echo::Int64=1, coil::Int64=1, slice::Int64=1;rep::Int64=1)\n\nreturns the k-space contained in acqData for given echo, coil, slice and rep(etition).\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.multiEchoData","page":"API","title":"MRIReco.multiEchoData","text":"multiEchoData(acqData::AcquisitionData, coil::Int64, slice::Int64;rep::Int64=1)\n\nreturns the k-space contained in acqData for all echoes and given coil, slice and rep(etition).\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.multiCoilData","page":"API","title":"MRIReco.multiCoilData","text":"multiCoilData(acqData::AcquisitionData, echo::Int64, slice::Int64;rep::Int64=1)\n\nreturns the k-space contained in acqData for all coils and given echo, slice and rep(etition).\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.multiCoilMultiEchoData","page":"API","title":"MRIReco.multiCoilMultiEchoData","text":"multiCoilMultiEchoData(acqData::AcquisitionData, echo::Int64, slice::Int64;rep::Int64=1)\n\nreturns the k-space contained in acqData for all coils, echoes and given slice and rep(etition).\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.profileData","page":"API","title":"MRIReco.profileData","text":"profileData(acqData::AcquisitionData, echo::Int64, slice::Int64, rep::Int, prof_tr::Int)\n\nreturns the profile-data prof_tr contained in acqData for given echo, coil, slice and rep(etition).\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.samplingDensity","page":"API","title":"MRIReco.samplingDensity","text":"samplingDensity(acqData::AcquisitionData,shape::Tuple)\n\nreturns the sampling density for all trajectories contained in acqData.\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.changeEncodingSize2D","page":"API","title":"MRIReco.changeEncodingSize2D","text":"changeEncodingSize2D(acqData::AcquisitionData,newEncodingSize::Vector{Int64})\n\nchanges the encoding size of 2d encoded acqData to newEncodingSize. Returns a new AcquisitionData object.\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.convert3dTo2d","page":"API","title":"MRIReco.convert3dTo2d","text":"convert3dTo2d(acqData::AcquisitionData)\n\nconvert the 3d encoded AcquisitionData acqData to the equivalent 2d AcquisitionData.\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.RawAcquisitionData","page":"API","title":"MRIReco.RawAcquisitionData","text":"RawAcquisitionData object.\n\nFields\n\nparams::Dict{String, Any} - Dict containing the information of the XML header in ISMRMRD\nprofiles::Vector{Profile} - Vector containing all the profiles of the acquisition\n\n\n\n\n\n","category":"type"},{"location":"API/#MRIReco.trajectory-Tuple{RawAcquisitionData}","page":"API","title":"MRIReco.trajectory","text":"trajectory(f::RawAcquisitionData; slice::Int=1, contrast::Int=1)\n\nreturns the Trajectory for given slice and contrast of a RawAcquisitionData object.\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.rawdata-Tuple{RawAcquisitionData}","page":"API","title":"MRIReco.rawdata","text":"rawdata(f::RawAcquisitionData)\n\nreturns the rawdata contained RawAcquisitionData object. The output is an Array{Matrix{ComplexF64},3}, which can be stored in a AcquisitionData object.\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.AcquisitionData-Tuple{RawAcquisitionData}","page":"API","title":"MRIReco.AcquisitionData","text":"AcquisitionData(f::RawAcquisitionData; estimateProfileCenter::Bool=false)\n\nconverts RawAcquisitionData into the equivalent AcquisitionData object.\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.RawAcquisitionData-2","page":"API","title":"MRIReco.RawAcquisitionData","text":"RawAcquisitionData(f::ISMRMRDFile, dataset=\"dataset\")\n\nreads the ISMRMRDFile f and stores the result in a RawAcquisitionDataObject\n\n\n\n\n\n","category":"type"},{"location":"API/#MRIReco.AcquisitionData-2","page":"API","title":"MRIReco.AcquisitionData","text":"AcquisitionData(f::ISMRMRDFile, dataset=\"dataset\")\n\nreads the ISMRMRDFile f and stores the result in an AcquisitionDataObject\n\n\n\n\n\n","category":"type"},{"location":"API/#Trajectories","page":"API","title":"Trajectories","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"MRIReco.Trajectory\nMRIReco.trajectory(trajName::AbstractString, numProfiles::Int, numSamplingPerProfile::Int; MRIReco.numSlices::Int64=1, TE::Float64=0.0, AQ::Float64=1.e-3, kargs...)\nMRIReco.string(tr::Trajectory)\nMRIReco.echoTime(tr::Trajectory)\nMRIReco.acqTimePerProfile(tr::Trajectory)\nMRIReco.numProfiles(tr::Trajectory)\nMRIReco.numSamplingPerProfile(tr::Trajectory)\nMRIReco.numSlices(tr::Trajectory)\nMRIReco.isCircular(tr::Trajectory)\nMRIReco.isCartesian(tr::Trajectory)\nMRIReco.dims(tr::Trajectory)\nMRIReco.kspaceNodes(tr::Trajectory)\nMRIReco.readoutTimes(tr::Trajectory)\nMRIReco.CartesianTrajectory\nMRIReco.EPITrajectory\nMRIReco.OneLine2dTrajectory\nMRIReco.RadialTrajectory\nMRIReco.SpiralTrajectory\nMRIReco.SpiralTrajectoryVarDens\nMRIReco.CartesianTrajectory3D\nMRIReco.KooshballTrajectory\nMRIReco.StackOfStarsTrajectory","category":"page"},{"location":"API/#MRIReco.Trajectory","page":"API","title":"MRIReco.Trajectory","text":"struct describing a trajectory\n\nFields\n\nname::String                  - name of the trajectory\nnodes::Matrix{Float64}        - sampling locations in k-space.                                   (1.dim <-> dimensions of k-space, 2. dim <-> sampling points)\ntimes::Vector{Float64}        - sampling times in s\nTE::Float64                   - echo time in s\nAQ::Float64`                  - readout duration in s (per profile)\nnumProfiles::Int64            - number of profiles\nnumSamplingPerProfile::Int64  - number of sampling points per profile\nnumSlices::Int64              - number of slices (for 3d trajectories)\ncartesian::Bool               - true if sampling points lie on a cartesian grid\ncircular::Bool                - true if kspace is covered in a circular domain\n\n\n\n\n\n","category":"type"},{"location":"API/#MRIReco.trajectory-Tuple{AbstractString, Int64, Int64}","page":"API","title":"MRIReco.trajectory","text":"trajectory(trajName::AbstractString, numProfiles::Int, numSamplingPerProfile::Int; numSlices::Int64=1, TE::Float64=0.0, AQ::Float64=1.e-3, kargs...)\n\nis a factory method to construct a trajectory from its name\n\nArguments\n\nname::String                  - name of the trajectory\nnumProfiles::Int64            - number of profiles\nnumSamplingPerProfile::Int64  - number of sampling points per profile\n(numSlices::Int64=1)          - number of slices (for 3d trajectories)\n(TE::Float64=0.0)             - echo time in s\n(AQ::Float64=1.e-3)           - readout duration in s (per profile)\nkargs...                      - addional keyword arguments\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.string-Tuple{Trajectory}","page":"API","title":"Base.string","text":"string(tr::Trajectory) returns the name of a trajectory \n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.echoTime-Tuple{Trajectory}","page":"API","title":"MRIReco.echoTime","text":"echoTime(tr::Trajectory) returns the echo time of a trajectory \n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.acqTimePerProfile-Tuple{Trajectory}","page":"API","title":"MRIReco.acqTimePerProfile","text":"acqTimePerProfile(tr::Trajectory) returns the acquisition time per profile of a trajectory \n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.numProfiles-Tuple{Trajectory}","page":"API","title":"MRIReco.numProfiles","text":"string(tr::Trajectory) returns the name of a trajectory \n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.numSamplingPerProfile-Tuple{Trajectory}","page":"API","title":"MRIReco.numSamplingPerProfile","text":"numSamplingPerProfile(tr::Trajectory) returns the number of samples per profile of a trajectory \n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.numSlices-Tuple{Trajectory}","page":"API","title":"MRIReco.numSlices","text":"numSlices(tr::Trajectory) returns the number of slices of a trajectory \n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.isCircular-Tuple{Trajectory}","page":"API","title":"MRIReco.isCircular","text":"isCircular(tr::Trajectory) returns whether the trajectory has circular k-space coverage \n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.isCartesian-Tuple{Trajectory}","page":"API","title":"MRIReco.isCartesian","text":"isCartesian(tr::Trajectory) returns whether the trajectory nodes lie on a cartesian grid\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.dims-Tuple{Trajectory}","page":"API","title":"MRIReco.dims","text":"dims(tr::Trajectory) returns the number of dimensions of a trajectory \n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.kspaceNodes-Tuple{Trajectory}","page":"API","title":"MRIReco.kspaceNodes","text":"kspaceNodes(tr::Trajectory) returns the kspace sampling points of a trajectory \n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.readoutTimes-Tuple{Trajectory}","page":"API","title":"MRIReco.readoutTimes","text":"readoutTimes(tr::Trajectory) returns the readoutTimes for the sampling points of a trajectory \n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.CartesianTrajectory","page":"API","title":"MRIReco.CartesianTrajectory","text":"CartesianTrajectory(numProfiles, numSamplingPerProfile\n              ; TE::Float64=0.0\n              , AQ::Float64=1.e-3\n              , kmin=(-0.5,-0.5)\n              , kmax=(0.5,0.5)\n              , kargs...)\n\nreturns a 2d cartesian trajectory.\n\nArguments\n\nnumProfiles::Int64            - number of profiles\nnumSamplingPerProfile::Int64  - number of sampling points per profile\n(TE::Float64=0.0)             - echo time in s\n(AQ::Float64=1.e-3)           - readout duration in s (per profile)\n(kmin=(-0.5,-0.5))            - minimum values of the covered k-space (for partial Fourier imaging)\n(kmax=(-0.5,-0.5))            - maximum values of the covered k-space (for partial Fourier imaging)\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.EPITrajectory","page":"API","title":"MRIReco.EPITrajectory","text":"EPITrajectory(numProfiles, numSamplingPerProfile\n              ; TE::Float64=0.0\n              , AQ::Float64=1.e-3\n              , EPI_factor::Int64=1\n              , profileOffset= :equispaced\n              , kargs...)\n\nreturns a 2d cartesian trajectory.\n\nArguments\n\nnumProfiles::Int64            - number of profiles\nnumSamplingPerProfile::Int64  - number of sampling points per profile\n(TE::Float64=0.0)             - echo time in s\n(AQ::Float64=1.e-3)           - readout duration in s (per profile)\n(EPI_factor::Int64=1)         - EPI factor, e.g. how many profiles to acquire per shot\n(profileOffset= :equispaced)  - equispaced or random ordering of the shots\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.OneLine2dTrajectory","page":"API","title":"MRIReco.OneLine2dTrajectory","text":"OneLine2dTrajectory(numProfiles, numSamplingPerProfile\n              ; TE::Float64=0.0\n              , AQ::Float64=1.e-3\n              , angle::Float64=0.0\n              , kargs...)\n\nreturns a trajectory consisting of one arbitrarily rotated profile.\n\nArguments\n\nnumProfiles::Int64            - number of profiles\nnumSamplingPerProfile::Int64  - number of sampling points per profile\n(TE::Float64=0.0)             - echo time in s\n(AQ::Float64=1.e-3)           - readout duration in s (per profile)\n(angle::Float64=0.0)          - angle of the profile (with respect to the x-axis) in radians\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.RadialTrajectory","page":"API","title":"MRIReco.RadialTrajectory","text":"RadialTrajectory(numProfiles, numSamplingPerProfile\n              ; TE::Float64=0.0\n              , AQ::Float64=1.e-3\n              , angleOffset= :equispaced\n              , kargs...)\n\nreturns a 2d radial trajectory.\n\nArguments\n\nnumProfiles::Int64            - number of profiles\nnumSamplingPerProfile::Int64  - number of sampling points per profile\n(TE::Float64=0.0)             - echo time in s\n(AQ::Float64=1.e-3)           - readout duration in s (per profile)\n(angleOffset= :equispaced)    - spacing of profile angles (:equispaced sampling, :golden angle sampling or :random sampling)\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.SpiralTrajectory","page":"API","title":"MRIReco.SpiralTrajectory","text":"SpiralTrajectory(numProfiles, numSamplingPerProfile\n              ; TE::Float64=0.0\n              , AQ::Float64=1.e-3\n              , windings::Real= 6.25\n              , angleOffset= :equispaced\n              , kargs...)\n\nreturns a 2d spiral trajectory.\n\nArguments\n\nnumProfiles::Int64            - number of profiles\nnumSamplingPerProfile::Int64  - number of sampling points per profile\n(TE::Float64=0.0)             - echo time in s\n(AQ::Float64=1.e-3)           - readout duration in s (per profile)\n(windings::Real= 6.25)        - number of windings of the spiral profiles\n(angleOffset= :equispaced)    - spacing of profile angles (:equispaced sampling, :golden angle sampling or :random sampling)\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.SpiralTrajectoryVarDens","page":"API","title":"MRIReco.SpiralTrajectoryVarDens","text":"SpiralTrajectoryVarDens(numProfiles, numSamplingPerProfile\n              ; TE::Float64=0.0\n              , AQ::Float64=1.e-3\n              , windings::Real= 6.25\n              , alpha=2.0\n              , angleOffset= :equispaced\n              , kargs...)\n\nreturns a 2d spiral trajectory with variable density\n\nArguments\n\nnumProfiles::Int64            - number of profiles\nnumSamplingPerProfile::Int64  - number of sampling points per profile\n(TE::Float64=0.0)             - echo time in s\n(AQ::Float64=1.e-3)           - readout duration in s (per profile)\n(windings::Real= 6.25)        - number of windings of the spiral profiles\n(alpha=2.0)                   - exponent describing the evolution of the magnitude of the sampling points along the profiles\n(angleOffset= :equispaced)    - spacing of profile angles (:equispaced sampling, :golden angle sampling or :random sampling)\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.CartesianTrajectory3D","page":"API","title":"MRIReco.CartesianTrajectory3D","text":"CartesianTrajectory3D(numProfiles, numSamplingPerProfile\n              ; TE::Float64=0.0\n              , AQ::Float64=1.e-3\n              , numSlices=1\n              , kargs...)\n\nreturns a 3d cartesian trajectory.\n\nArguments\n\nnumProfiles::Int64            - number of profiles\nnumSamplingPerProfile::Int64  - number of sampling points per profile\n(TE::Float64=0.0)             - echo time in s\n(AQ::Float64=1.e-3)           - readout duration in s (per profile)\n(numSlices=1)                 - number of slices\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.KooshballTrajectory","page":"API","title":"MRIReco.KooshballTrajectory","text":"KooshballTrajectory(numProfiles, numSamplingPerProfile\n              ; TE::Float64=0.0\n              , AQ::Float64=1.e-3\n              , kargs...)\n\nreturns a 3d kooshball trajectory.\n\nArguments\n\nnumProfiles::Int64            - number of profiles\nnumSamplingPerProfile::Int64  - number of sampling points per profile\n(TE::Float64=0.0)             - echo time in s\n(AQ::Float64=1.e-3)           - readout duration in s (per profile)\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.StackOfStarsTrajectory","page":"API","title":"MRIReco.StackOfStarsTrajectory","text":"StackOfStarsTrajectory(numProfiles, numSamplingPerProfile\n              ; TE::Float64=0.0\n              , AQ::Float64=1.e-3\n              , numSlices=1\n              , angleOffset= :equispaced\n              , kargs...)\n\nreturns a 2d radial trajectory.\n\nArguments\n\nnumProfiles::Int64            - number of profiles\nnumSamplingPerProfile::Int64  - number of sampling points per profile\n(TE::Float64=0.0)             - echo time in s\n(AQ::Float64=1.e-3)           - readout duration in s (per profile)\n(numSlices=1)                 - number of slices\n(angleOffset= :equispaced)    - spacing of profile angles (:equispaced sampling, :golden angle sampling or :random sampling)\n\n\n\n\n\n","category":"function"},{"location":"API/#Sequences","page":"API","title":"Sequences","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"MRIReco.MESequence\nMRIReco.numContrasts(seq::MESequence)\nMRIReco.echoTimes(seq::MESequence)\nMRIReco.flipAngles(seq::MESequence)\nMRIReco.echoAmplitudes(seq::MESequence, R1::Float64, R2::Float64, numStates=nothing)\nMRIReco.epgAmplitudes(seq::MESequence, R1::Real, R2::Real, numStates=nothing)\nMRIReco.epgRotation\nMRIReco.epgRelaxation\nMRIReco.epgDephasing\nMRIReco.rfRotation","category":"page"},{"location":"API/#MRIReco.MESequence","page":"API","title":"MRIReco.MESequence","text":"General Multi-Echo sequence with variable flip angles and TR.\n\nThe phase of the excitation pulse has a phase of -90° in order to fulfill CPMG conditions.\n\nFor simplicity instantaneous pulses are assumed.\n\nechoes apperat at times Techo, 2*Techo,..., numContrasts*T_echo after the excitation pulse\n\nFields\n\nexcitationAngle::Float64            - flip angle of the excitation pulse\nrefocusingAngles :: Vector{Float64} - flip angles of the refocusing pulses\nT_rf::Vector{Float64}               - times of the refocusing pulses relative to the excitation pulse\nT_echo:: Vector{Float64}            - echo times relative to the excitation pulse\n\n\n\n\n\n","category":"type"},{"location":"API/#MRIReco.numContrasts-Tuple{MESequence}","page":"API","title":"MRIReco.numContrasts","text":"numContrasts(seq::MESequence)\n\nreturns the number of echoes of an ME Sequence\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.echoTimes-Tuple{MESequence}","page":"API","title":"MRIReco.echoTimes","text":"echoTimes(seq::MESequence)\n\nreturns the echo times of an ME Sequence\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.flipAngles-Tuple{MESequence}","page":"API","title":"MRIReco.flipAngles","text":"flipAngles(seq::MESequence)\n\nreturns the refocusing flip angles of an ME Sequence\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.echoAmplitudes","page":"API","title":"MRIReco.echoAmplitudes","text":"echoAmplitudes(seq::MESequence, R1::Float64, R2::Float64, numStates=nothing)\n\ncalculates echo amplitudes for a given MESequence and given relaxation Rates R1, R2. Calculations are performed using the extended phase graph method. For simplicity instantaneous pulses are assumed. If numStates=nothing all dephasing states will be taken into account\n\nArguments\n\nseq::MESequence - pulse sequence\nR1::Float64 - R1 value to use (1/T1)\nR2::Float64 - R2 value to use (1/T2)\nnumStates=nothing - number of dephasing states to consider\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.epgAmplitudes","page":"API","title":"MRIReco.epgAmplitudes","text":"epgAmplitudes(seq::MESequence, R1::Float64, R2::Float64, numStates=nothing)\n\ncalculates EPG amplitudes after each pulse of a given MESequence with the given relaxation Rates R1, R2. Calculations are performed using the extended phase graph method. For simplicity instantaneous pulses are assumed. If numStates=nothing all dephasing states will be taken into account\n\nArguments\n\nseq::MESequence - pulse sequence\nR1::Float64 - R1 value to use (1/T1)\nR2::Float64 - R2 value to use (1/T2)\nnumStates=nothing - number of dephasing states to consider\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.epgRotation","page":"API","title":"MRIReco.epgRotation","text":"epgRotation(alpha::Float64, F::Vector{T}, Z::Vector{T}; statesConsidered=nothing, phi::Float64=0.0)\n\napplies Bloch-rotation (<=> RF pulse) to a set of EPG states.\n\nArguments\n\nalpha::Float64           - flip angle of the RF pulse\nF::Vector{T}             - transverse dephasing stats\nZ::Vector{T}             - longitudinal dephasing stats\nstatesConsidered=nothing - number of dephasing states to consider (nothing means all states are taken into account)\nphi::Float64=0.0         - phase of the RF pulse\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.epgRelaxation","page":"API","title":"MRIReco.epgRelaxation","text":"epgRelaxation( R1::Float64, R2::Float64, t::Float64, F::Vector{T}, Z::Vector{T}) where T\n\napplies relaxation matrices to a set of EPG states.\n\nArguments\n\nR1::Float64   - R1\nR2::Float64   - R2\nt::Float64    - length of time interval in s\nF::Vector{T}  - transverse dephasing stats\nZ::Vector{T}  - longitudinal dephasing stats\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.epgDephasing","page":"API","title":"MRIReco.epgDephasing","text":"epgDephasing(F::Vector{T}, n=1) where T = circshift(F[:],n)\n\nshifts the transverse dephasing states F corresponding to n dephasing-cycles.\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.rfRotation","page":"API","title":"MRIReco.rfRotation","text":"rfRotation(alpha, phi=0.)\n\nreturns the rotation matrix for a pulse with flip angle alpha and phase phi.\n\n\n\n\n\n","category":"function"},{"location":"API/#Sampling","page":"API","title":"Sampling","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"MRIReco.sample\nMRIReco.sample_kspace(data::AbstractArray,redFac::Float64,patFunc::AbstractString;kargs...)\nMRIReco.sample_kspace(acqData::AcquisitionData,redFac::Float64,\n                       patFunc::AbstractString; rand=true, profiles=true,\n                       seed = 1234, kargs...)\nMRIReco.sample_regular(shape::Tuple, redFac::Float64; kargs...)\nMRIReco.sample_random(shape::Tuple{Int64,Int64},redFac::Float64;calsize::Int64=0,kargs...)\nMRIReco.sample_poissondisk(shape::Tuple{Int64,Int64},redFac::Float64;calsize::Int64=0, seed::Int64=1234,kargs...)\nMRIReco.sample_vdpoisson(shape::Tuple{Int64,Int64},redFac::Float64; seed::Int64=1234,kargs...)\nMRIReco.sample_lines(shape::Tuple{Int64,Int64},redFac::Float64;sampleFunc=\"random\",kargs...)\nMRIReco.calculateIncoherence(acqData::AcquisitionData, recoParams::Dict, slice=1)","category":"page"},{"location":"API/#MRIReco.sample","page":"API","title":"MRIReco.sample","text":"sample(shape::NTuple{N,Int64}, redFac::Float64, patFunc::String; kargs...)\n\ngenerates a Vector{Int64} of indices to sample an Array of of size shape with a reduction factor redFac.\n\nArguments\n\nshape::NTuple{N,Int64} - size of the Array to be sampled\nredFac::Float64        - subsampling factor\npatFunc::String        - name of the sampling function                           (\"random, \"regular\", \"lines\", \"poisson\" or \"vdPoisson\")\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.sample_kspace-Tuple{AbstractArray, Float64, AbstractString}","page":"API","title":"MRIReco.sample_kspace","text":"sample_kspace(data::AbstractArray, redFac::Float64, patFunc::String; kargs...)\n\nsubsamples the Array data with a reduction factor redFac and returns both the subsampled Array (as a vector) and the sampled indices (as a vector)\n\nArguments\n\ndata::AbstractArray    - array to be sampled\nredFac::Float64        - subsampling factor\npatFunc::String        - name of the sampling function                           (\"random, \"regular\", \"lines\", \"poisson\" or \"vdPoisson\")\nkargs...               - addional keyword arguments\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.sample_kspace-Tuple{AcquisitionData, Float64, AbstractString}","page":"API","title":"MRIReco.sample_kspace","text":"sample_kspace(acqData::AcquisitionData,redFac::Float64,\n            patFunc::AbstractString; rand=true, profiles=true,\n            seed = 1234, kargs...)\n\nsubsamples the data in acqData with reduction factor redFac and returns a new AcquisitionData object.\n\nArguments\n\nacqData::AcquisitionDatay - AcquisitionData to be sampled\nredFac::Float64           - subsampling factor\npatFunc::String           - name of the sampling function                               (\"random, \"regular\", \"lines\", \"poisson\" or \"vdPoisson\")\n(rand=true)               - use different patterns for the different contrasts\n(profiles=true)           - sample complete profiles\n(seed=1234)               - seed for the random number generator\nkargs...                  - addional keyword arguments\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.sample_regular-Tuple{Tuple, Float64}","page":"API","title":"MRIReco.sample_regular","text":"sample_regular(shape::Tuple{Int64,Int64},redFac::Float64;kargs...)\n\ngenerates a regular sampling pattern for an Array of size shape with a subsampling factor redFac.\n\nArguments\n\nshape::NTuple{N,Int64} - size of the Array to be sampled\nredFac::Float64        - subsampling factor\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.sample_random-Tuple{Tuple{Int64, Int64}, Float64}","page":"API","title":"MRIReco.sample_random","text":"sample_random(shape::Tuple{Int64,Int64},redFac::Float64;calsize::Int64=0,kargs...)\n\ngenerates a random sampling pattern for an Array of size shape with a subsampling factor redFac.\n\nArguments\n\nshape::NTuple{N,Int64} - size of the Array to be sampled\nredFac::Float64        - subsampling factor\n(calsize::Int64=0)     - size of the fully sampled calibration area\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.sample_poissondisk-Tuple{Tuple{Int64, Int64}, Float64}","page":"API","title":"MRIReco.sample_poissondisk","text":"sample_poissondisk(shape::Tuple{Int64,Int64},redFac::Float64;calsize::Int64=0, seed::Int64=1234,kargs...)\n\ngenerates a Poisson disk sampling pattern for an Array of size shape with a subsampling factor redFac.\n\nArguments\n\nshape::NTuple{2,Int64} - size of the Array to be sampled\nredFac::Float64        - subsampling factor\n(calsize::Int64=0)     - size of the fully sampled calibration area\n(seed=1234)            - seed for the random number generator\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.sample_vdpoisson-Tuple{Tuple{Int64, Int64}, Float64}","page":"API","title":"MRIReco.sample_vdpoisson","text":"sample_vdpoisson(shape::Tuple{Int64,Int64},redFac::Float64; seed::Int64=1234,kargs...)\n\ngenerates a variable density Poisson disk sampling pattern for an Array of size shape with a subsampling factor redFac.\n\nArguments\n\nshape::NTuple{2,Int64} - size of the Array to be sampled\nredFac::Float64        - subsampling factor\n(seed=1234)            - seed for the random number generator\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.sample_lines-Tuple{Tuple{Int64, Int64}, Float64}","page":"API","title":"MRIReco.sample_lines","text":"sample_lines(shape::Tuple{Int64,Int64},redFac::Float64;sampleFunc=\"random\",kargs...)\n\ngenerates a pattern to sample complete lines of an Array of size shape with a subsampling factor redFac.\n\nArguments\n\nshape::NTuple{N,Int64} - size of the Array to be sampled\nredFac::Float64        - subsampling factor\nsampleFunc=\"random\"        - name of the sampling function                           (\"random, \"regular\", \"lines\", \"poisson\" or \"vdPoisson\")\nkargs...               - addional keyword arguments\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.calculateIncoherence","page":"API","title":"MRIReco.calculateIncoherence","text":"calculateIncoherence(acqData::AcquisitionData, recoParams::Dict, slice=1)\n\ncalculates the incoherence of the sampling pattern contained in acqData\n\nArguments\n\nacqData::AcquisitionData  - AcquisitionData containing the sampling pattern\nrecoParams::Dict          - Dict containing reconstruction parameters\n(slice=1)                 - slice for which to calculate the incoherence\n\n\n\n\n\n","category":"function"},{"location":"API/#Simulation","page":"API","title":"Simulation","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"MRIReco.simulation(image::Array{T,3}, simParams::Dict) where T<:Union{ComplexF64,Float64}\nMRIReco.simulation(image::Array{T,3}, simParams::Dict, filename::String;\n                        force=false) where T<:Union{ComplexF64,Float64}\nMRIReco.simulation(image::Array{T,2}, simParams::Dict) where T<:Union{ComplexF64,Float64}\nMRIReco.simulation(tr::Trajectory\n                    , image::Array{ComplexF64}\n                    , correctionMap = []\n                    ; opName=\"fast\"\n                    , senseMaps=[]\n                    , verbose=true\n                    , kargs...)\nMRIReco.simulation(seq::AbstractSequence, tr::Vector{Trajectory}\n                    , image::Array{ComplexF64,3}\n                    ; opName=\"fast\"\n                    , r1map=[]\n                    , r2map=[]\n                    , fmap=[]\n                    , senseMaps=[]\n                    , verbose=true\n                    , kargs...)\nMRIReco.addNoise(x::Vector, snr::Float64, complex= true)\nMRIReco.addNoise(acqData::AcquisitionData, snr::Float64)\nMRIReco.addNoise!(acqData::AcquisitionData, snr::Float64)\nMRIReco.birdcageSensitivity\nMRIReco.quadraticFieldmap","category":"page"},{"location":"API/#MRIReco.simulation-Union{Tuple{T}, Tuple{Array{T, 3}, Dict}} where T<:Union{Float64, ComplexF64}","page":"API","title":"MRIReco.simulation","text":"simulation(image::Array{T,3}, simParams::Dict) where T<:Union{ComplexF64,Float64}\n\nSimulate MRI raw data from given image data. All simulation parameters are passed to the function in the form of a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.simulation-Union{Tuple{T}, Tuple{Array{T, 3}, Dict, String}} where T<:Union{Float64, ComplexF64}","page":"API","title":"MRIReco.simulation","text":"simulation(image::Array{T,3}, simParams::Dict, filename::String) where T<:Union{ComplexF64,Float64}\n\nPerforms the same simulation as simulation(image, simParams) and saves the result in a file with name filename\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.simulation-Union{Tuple{T}, Tuple{Matrix{T}, Dict}} where T<:Union{Float64, ComplexF64}","page":"API","title":"MRIReco.simulation","text":"simulation(image::Array{T,2}, simParams::Dict) where T<:Union{ComplexF64,Float64}\n\nSimulate MRI raw data from given image data. All simulation parameters are passed to the function in the form of a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.simulation","page":"API","title":"MRIReco.simulation","text":"simulation(tr::Trajectory, image::Array{ComplexF64}, correctionMap = []; opName=\"fast\"\n          , senseMaps=[], verbose=true, kargs...)\n\nTransforms a given image to k-space Domain. Dispatches whether the trajectory is 2d or 3d The Fourier integrals can be evaluated exactly or using NFFT Returns the demodulated signal.\n\n...\n\nArguments\n\ntr::Trajectory             - three-dimensional Trajectory\nimage::Array{ComplexF64,3} - image to be transformed\n(correctionMap=[])         - sum of the field offresonance (imaginary) map and relaxation map (real)\n(`opName=\"fast\")             - name of operator to use (\"explicit\" or \"fast\")\n(sensmaps=[])              - array of coil sensitivities\n(verbose=true)             - prints the progress if true\nkargs...                   - addional keyword arguments\n\n...\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.simulation-Tuple{AbstractSequence, Vector{Trajectory}, Array{ComplexF64, 3}}","page":"API","title":"MRIReco.simulation","text":"simulation(seq::AbstractSequence, tr::Vector{Trajectory}, image::Array{ComplexF64,3}\n                ; opName=\"fast\", r1map=[], r2map=[], fmap=[], senseMaps=[]\n                , verbose=true, kargs...)\n\nSimulate k-space data for all echoes of a pulse sequence. The echo intensities are simulated using the EPG formalism The Fourier integrals can be evaluated exactly or using NFFT\n\n...\n\nArguments\n\nseq::AbstractSequence      - pulse sequence\ntr::Vector{Trajectory}     - trajectories for all contrasts\nimage::Array{ComplexF64,3} - image to be transformed\n(r1map=[])                 - R1 map of the object (real)\n(r2map=[])                 - R2 map of the object (real) / (R2* for GRE sequences)\n(fmap=[])                  - fieldmap (real)\n(`opName=\"fast\")             - name of operator to use (\"explicit\" or \"fast\")\n(sensmaps=[])              - array of coil sensitivities\n(verbose=true)             - prints the progress if true\nkargs...                   - addional keyword arguments\n\n...\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.addNoise","page":"API","title":"MRIReco.addNoise","text":"Adds average white gaussian noise to the signal x\n\nArguments\n\nx::Vector     - signal vector\n'snr::Float64'  - target SNR\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.addNoise-Tuple{AcquisitionData, Float64}","page":"API","title":"MRIReco.addNoise","text":"return AcquisitionData with white gaussian noise\n\nArguments\n\nacqData::AcquisitionData  - AcquisitionData\n'snr::Float64'              - target SNR\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.addNoise!-Tuple{AcquisitionData, Float64}","page":"API","title":"MRIReco.addNoise!","text":"add white gaussian noise to AcquisitionData with (in-place)\n\nArguments\n\nacqData::AcquisitionData  - AcquisitionData\n'snr::Float64'              - target SNR\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.birdcageSensitivity","page":"API","title":"MRIReco.birdcageSensitivity","text":"birdcageSensitivity(N::Int64, ncoils::Int64, relative_radius::Float64)\n\nComputes the sensitivity maps for each coils that are arranged in a birdcage manner.\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.quadraticFieldmap","page":"API","title":"MRIReco.quadraticFieldmap","text":"quadraticFieldmap(Nx::Int64, Ny::Int64, maxOffresonance::Float64=125.0)\n\nComputes a parabolic fieldmap.\n\n\n\n\n\n","category":"function"},{"location":"API/#Reconstruction","page":"API","title":"Reconstruction","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"MRIReco.reconstruction(acqData::AcquisitionData, recoParams::Dict)\nMRIReco.reconstruction(acqData::AcquisitionData, recoParams::Dict, filename::String;force=false)\nMRIReco.setupIterativeReco\nMRIReco.reconstruction_direct_2d\nMRIReco.reconstruction_direct_3d\nMRIReco.reconstruction_simple\nMRIReco.reconstruction_multiEcho\nMRIReco.reconstruction_multiCoil\nMRIReco.reconstruction_multiCoilMultiEcho\nMRIReco.espirit\nMRIReco.nrmsd","category":"page"},{"location":"API/#MRIReco.reconstruction-Tuple{AcquisitionData, Dict}","page":"API","title":"MRIReco.reconstruction","text":"reconstruction(acqData::AcquisitionData, recoParams::Dict)\n\nPerforms image reconstruction of an AcquisitionData object. Parameters are specified in a dictionary.\n\nReconstruction types are specified by the symbol :reco. Valid reconstruction names are:\n\n:direct - direct Fourier reconstruction\n:standard           - iterative reconstruction for all contrasts, coils & slices independently\n:multiEcho          - iterative joint reconstruction of all echo images\n:multiCoil          - SENSE-type iterative reconstruction\n:multiCoilMultiEcho - SENSE-type iterative reconstruction of all echo images\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.reconstruction-Tuple{AcquisitionData, Dict, String}","page":"API","title":"MRIReco.reconstruction","text":"reconstruction(acqData::AcquisitionData, recoParams::Dict,filename::String; force=false)\n\nperforms the same image reconstrucion as reconstruction(acqData::AcquisitionData, recoParams::Dict) and saves the image in a file with name filename. If force=false, the reconstructed image is loaded from the the file filename if the latter is present.\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.setupIterativeReco","page":"API","title":"MRIReco.setupIterativeReco","text":"setupIterativeReco(acqData::AcquisitionData, recoParams::Dict)\n\nbuilds relevant parameters and operators from the entries in recoParams\n\nrelevant parameters\n\nreconSize::NTuple{2,Int64}              - size of image to reconstruct\nweights::Vector{Vector{ComplexF64}} - sampling density of the trajectories in acqData\nsparseTrafo::AbstractLinearOperator - sparsifying transformation\nreg::Regularization                 - Regularization to be used\nnormalize::Bool                     - adjust regularization parameter according to the size of k-space data\nsolvername::String                  - name of the solver to use\nsenseMaps::Array{ComplexF64}        - coil sensitivities\ncorrectionMap::Array{ComplexF64}    - fieldmap for the correction of off-resonance effects\nmethod::String=\"nfft\"               - method to use for time-segmentation when correctio field inhomogeneities\n\nsparseTrafo and reg can also be speficied using their names in form of a string.\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.reconstruction_simple","page":"API","title":"MRIReco.reconstruction_simple","text":"Performs iterative image reconstruction independently for the data of all coils, contrasts and slices\n\nArguments\n\nacqData::AcquisitionData            - AcquisitionData object\nreconSize::NTuple{2,Int64}              - size of image to reconstruct\nreg::Regularization                 - Regularization to be used\nsparseTrafo::AbstractLinearOperator - sparsifying transformation\nweights::Vector{Vector{ComplexF64}} - sampling density of the trajectories in acqData\nsolvername::String                  - name of the solver to use\n(normalize::Bool=false)             - adjust regularization parameter according to the size of k-space data\n(params::Dict{Symbol,Any})          - Dict with additional parameters\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.reconstruction_multiEcho","page":"API","title":"MRIReco.reconstruction_multiEcho","text":"Performs a iterative image reconstruction jointly for all contrasts. Different slices and coil images are reconstructed independently.\n\nArguments\n\nacqData::AcquisitionData            - AcquisitionData object\nreconSize::NTuple{2,Int64}              - size of image to reconstruct\nreg::Regularization                 - Regularization to be used\nsparseTrafo::AbstractLinearOperator - sparsifying transformation\nweights::Vector{Vector{ComplexF64}} - sampling density of the trajectories in acqData\nsolvername::String                  - name of the solver to use\n(normalize::Bool=false)             - adjust regularization parameter according to the size of k-space data\n(params::Dict{Symbol,Any})          - Dict with additional parameters\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.reconstruction_multiCoil","page":"API","title":"MRIReco.reconstruction_multiCoil","text":"Performs a SENSE-type iterative image reconstruction. Different slices and contrasts images are reconstructed independently.\n\nArguments\n\nacqData::AcquisitionData            - AcquisitionData object\nreconSize::NTuple{2,Int64}              - size of image to reconstruct\nreg::Regularization                 - Regularization to be used\nsparseTrafo::AbstractLinearOperator - sparsifying transformation\nweights::Vector{Vector{ComplexF64}} - sampling density of the trajectories in acqData\nsolvername::String                  - name of the solver to use\nsenseMaps::Array{ComplexF64}        - coil sensitivities\n(normalize::Bool=false)             - adjust regularization parameter according to the size of k-space data\n(params::Dict{Symbol,Any})          - Dict with additional parameters\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.reconstruction_multiCoilMultiEcho","page":"API","title":"MRIReco.reconstruction_multiCoilMultiEcho","text":"Performs a SENSE-type iterative image reconstruction which reconstructs all contrasts jointly. Different slices are reconstructed independently.\n\nArguments\n\nacqData::AcquisitionData            - AcquisitionData object\nreconSize::NTuple{2,Int64}              - size of image to reconstruct\nreg::Regularization                 - Regularization to be used\nsparseTrafo::AbstractLinearOperator - sparsifying transformation\nweights::Vector{Vector{ComplexF64}} - sampling density of the trajectories in acqData\nsolvername::String                  - name of the solver to use\nsenseMaps::Array{ComplexF64}        - coil sensitivities\n(normalize::Bool=false)             - adjust regularization parameter according to the size of k-space data\n(params::Dict{Symbol,Any})          - Dict with additional parameters\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.espirit","page":"API","title":"MRIReco.espirit","text":"espirit(acqData::AcquisitionData, ksize::NTuple{2,Int} = (6,6), ncalib::Int = 24\n           ; eigThresh_1::Number=0.02, eigThresh_2::Number=0.95, nmaps = 1)\n\nespirit(calibData::Array{T}, imsize::NTuple{N,Int}, ksize::NTuple{N,Int} = (6,6[,6])\n           ; eigThresh_1::Number = 0.02, eigThresh_2::Number = 0.95, nmaps = 1)\n\nObtains coil sensitivities from a calibration area using ESPIRiT. The code is adapted from the MATLAB code by Uecker et al. (cf. Uecker et al. \"ESPIRiT—an eigenvalue approach to autocalibrating parallel MRI: Where SENSE meets GRAPPA\"). The matlab code can be found at: [http://people.eecs.berkeley.edu/~mlustig/Software.html]\n\nMethod 1\n\nThe first method of this function works with 2D/multi-slice data in the MRIReco.jl data format:\n\nespirit(acqData::AcquisitionData, ksize::NTuple{2,Int} = (6,6), ncalib::Int = 24\n          ; eigThresh_1::Number=0.02, eigThresh_2::Number=0.95)\n\nRequired Arguments\n\nacqData::AcquisitionData  - AcquisitionData\n\nOptional Arguments\n\nksize::NTuple{2,Int64}    - size of the k-space kernel; default = (6,6)\nncalib::Int64             - number of calibration points in each dimension; default = 30\n\nKeyword Arguments\n\neigThresh_1::Number=0.02  - threshold for the singular values of the calibration matrix (relative to the largest value); reduce for more accuracy, increase for saving memory and computation time.\neigThresh_2::Number=0.95  - threshold to mask the final maps: for each voxel, the map will be set to 0, if, for this voxel, no singular value > eigThresh_2 exists.\nnmaps = 1                 - Number of maps that are calcualted. Set to 1 for regular SENSE; set to 2 for soft-SENSE (cf. Uecker et al. \"ESPIRiT—an eigenvalue approach to autocalibrating parallel MRI: Where SENSE meets GRAPPA\").\n\nMethod 2\n\nThe second method of this function works with single slice 2D or 3D data; the first argument is the calibration data, i.e. the cropped center of k-space:\n\nespirit(calibData::Array{T}, imsize::NTuple{N,Int}, ksize::NTuple{N,Int} = (6,6[,6])\n          ; eigThresh_1::Number = 0.02, eigThresh_2::Number = 0.95, nmaps = 1)\n\nRequired Arguments\n\ncalibData::Array{T}       - Center of k-space in the format kx × ky [× kz] × coils, where the kz dimension is optional. The type T of the input data determines the type of the calculated maps. Reasonable choises are in the range of Nx = Ny [= Nz] = 24.\nimsize::NTuple{N,Int}     - matrix size of the final maps\n\nOptional Arguments\n\nksize::NTuple{N,Int}      - number of calibration points in each dimension; the default is (6,6) for 2D and (6,6,6) for 3D.\n\nKeyword Arguments\n\neigThresh_1::Number=0.02  - threshold for the singular values of the calibration matrix (relative to the largest value); reduce for more accuracy, increase for saving memory and computation time.\neigThresh_2::Number=0.95  - threshold to mask the final maps: for each voxel, the map will be set to 0, if, for this voxel, no singular value > eigThresh_2 exists.\nnmaps = 1                 - Number of maps that are calcualted. Set to 1 for regular SENSE; set to 2 for soft-SENSE (cf. Uecker et al. \"ESPIRiT—an eigenvalue approach to autocalibrating parallel MRI: Where SENSE meets GRAPPA\").\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.nrmsd","page":"API","title":"MRIReco.nrmsd","text":"nrmsd(I,Ireco)\n\ncomputes the normalized root mean squared error of the image Ireco with respect to the image I.\n\n\n\n\n\n","category":"function"},{"location":"operators/#Imaging-Operators","page":"Imaging Operators","title":"Imaging Operators","text":"","category":"section"},{"location":"operators/","page":"Imaging Operators","title":"Imaging Operators","text":"The mapping between the proton density and the recorded signal is linear in MRI and can be described in the continuous case as an integral equation and in the discrete case as a matrix vector multiplication.","category":"page"},{"location":"operators/","page":"Imaging Operators","title":"Imaging Operators","text":"Depending on the imaging scenario, the MRI system matrix can have various different forms. It may encode a Cartesian, or a spiral trajectory. It may take offresonance into account, and it may also encode the sensitivity of the receive coil.","category":"page"},{"location":"operators/","page":"Imaging Operators","title":"Imaging Operators","text":"MRIReco implements various MRI imaging operators. In all cases, the operators have a dedicated Julia type that acts as a matrix. The operator E thus can be applied to a vector x by calling E*x. Similarly, the adjoint can be applied by adjoint(E)*x. We note at this point that the adjoint operation is lazy in Julia and thus the matrix adjoint(E) is never explicitly arranged.","category":"page"},{"location":"operators/","page":"Imaging Operators","title":"Imaging Operators","text":"MRIReco currently implements the following operators:","category":"page"},{"location":"operators/","page":"Imaging Operators","title":"Imaging Operators","text":"FFTOp: A multidimensional FFT operator\nNFFTOp: A multidimensional operator for non-equidistant FFTs\nFieldmapNFFTOp: An operator that takes complex correction terms into account\nSensitivityMapOp: An operator for building a SENSE reconstruction. Has to be combined with one of the former encoding operators\nSamplingOp: An operator that describes the (sub)sampling of full trajectories. The operator is used for Compressed Sensing reconstruction\nWaveletOp: A multidimensional operator for applying Wavelet transformations","category":"page"},{"location":"operators/","page":"Imaging Operators","title":"Imaging Operators","text":"Each of these operators can be build by calling the corresponding constructor. Alternatively one can use the EncodingOp constructor that allows for high-level construction of the imaging operator.","category":"page"},{"location":"SENSE/#Parallel-Imaging","page":"Parallel Imaging","title":"Parallel Imaging","text":"","category":"section"},{"location":"SENSE/","page":"Parallel Imaging","title":"Parallel Imaging","text":"For parallel imaging MRIReco.jl uses an iterative SENSE approach. In the following code example we show how to simulate MRI data with an array of 8 coils and how to reconstruct that data using SENSE. The example can be run by entering","category":"page"},{"location":"SENSE/","page":"Parallel Imaging","title":"Parallel Imaging","text":"include(joinpath(dirname(pathof(MRIReco)),\"../docs/src/examples/exampleSENSE.jl\"))","category":"page"},{"location":"SENSE/","page":"Parallel Imaging","title":"Parallel Imaging","text":"into the Julia REPL.","category":"page"},{"location":"SENSE/","page":"Parallel Imaging","title":"Parallel Imaging","text":"N = 256\nnumCoils = 8\nI = shepp_logan(N)\nI = circularShutterFreq!(I,1)\n\ncoilsens = birdcageSensitivity(N, 8, 1.5)\n\n# simulation parameters\nparams = Dict{Symbol, Any}()\nparams[:simulation] = \"fast\"\nparams[:trajName] = \"Spiral\"\nparams[:numProfiles] = 6\nparams[:numSamplingPerProfile] = div(N*N,16)\nparams[:windings] = div(N,16)\nparams[:AQ] = 2.0e-2\nparams[:senseMaps] = coilsens\n\n# do simulation\nacqData = simulation(I, params)\n\n# reco parameters\nparams = Dict{Symbol, Any}()\nparams[:reco] = \"multiCoil\"\nparams[:reconSize] = (N,N)\nparams[:regularization] = \"L2\"\nparams[:λ] = 1.e-3\nparams[:iterations] = 40\nparams[:solver] = \"cgnr\"\nparams[:senseMaps] = coilsens\n\n# do reconstruction\nIreco = reconstruction(acqData, params)\n","category":"page"},{"location":"SENSE/","page":"Parallel Imaging","title":"Parallel Imaging","text":"Below one can see the orignal phantom on the left and the reconstruction on the right:","category":"page"},{"location":"SENSE/","page":"Parallel Imaging","title":"Parallel Imaging","text":"(Image: Phantom) (Image: Reconstruction)","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"As outlined in the introduction MRIReco.jl MRIReco has the philosophy to to reuse functionality provided by other Julia package and basically add the MRI specific functionality. This approach is enabled by the Julia package manager that can handle all dependencies automatically. Packages are therefore considered to be cheap in Julia so that modularization can be done across packages. In the following graph, the most important (not all) dependencies of MRIReco are visualized.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: Dependencies)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Most importantly, all iterative solvers are implemented in RegularizedLeastSquares.jl so that MRIReco can benefit from all improvements made in that package. Gridding is implemented in the NFFT.jl package, which has many applications byond MRI. Sparsifying transformations are usually also not MRI specific and therefore implemented in independent packages (e.g. Wavelets.jl). For storing image data MRIReco.jl uses NiFTI.jl. Dicom data can potentially be saved by the DICOM.jl package, which, however, is not a hard dependency of MRIReco.","category":"page"},{"location":"overview/#Data-Types-and-Flow","page":"Overview","title":"Data Types and Flow","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"An overview about the most important data types and the data flow during recosntruction is given in the following figure.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: DataFlow)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Raw data is usually obtained from files (discussed in File Handling). Since the data layout of the RawAcquisitionData object is not perfectly suited for reconstruction, we  ","category":"page"},{"location":"#MRIReco.jl","page":"Home","title":"MRIReco.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Magnetic Resonance Imaging Reconstruction","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MRIReco is a Julia packet for magnetic resonance imaging. It contains algorithms for the simulation and reconstruction of MRT data and is both easy to use and flexibly expandable.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Both direct and iterative methods are available for image reconstruction. In particular, modern compressed sensing algorithms such as ADMM can be used.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The MRT imaging operator can be set up for a variety of scanning patterns (cartesian, spiral, radial, ...) and can take into account field inhomogeneity as well as the use of coil arrays. The operator can be quickly evaluated using NFFT-based methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"One strength of the package is that it is strongly modular and uses high quality Julia packages. These are e.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"NFFT.jl and FFTW.jl for fast Fourier transformations\nWavelets.jl for sparsification\nLinearOperators.jl in order to be able to divide the imaging operator modularly into individual parts\nRegularizedLeastSquares.jl for modern algorithms for solving linear optimization problems","category":"page"},{"location":"","page":"Home","title":"Home","text":"This interaction allows new algorithms to be easily integrated into the software framework. It is not necessary to program in C/C++ but the advantages of the scientific high-level language Julia can be used.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nMRIReco.jl is work in progress and in some parts not entirely optimized. In particular the FFT and NFFT implementation are currently limited to the CPU and do not support GPU acceleration yet.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Start julia and open the package mode by entering ]. Then enter","category":"page"},{"location":"","page":"Home","title":"Home","text":"add MRIReco","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install MRIReco and all its dependencies. If you want to develop MRIReco itself you can checkout MRIReco by calling","category":"page"},{"location":"","page":"Home","title":"Home","text":"dev MRIReco","category":"page"},{"location":"","page":"Home","title":"Home","text":"More information on how to develop a package can be found in the Julia documentation.","category":"page"},{"location":"#Plotting","page":"Home","title":"Plotting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"On purpose MRIReco is not depending on a particular plotting package since there are various plotting packages in the Julia ecosystem. Within the examples outlined in the tutorial we will use PyPlot for plotting but you may prefer using the Plots package. You can add both packages the same way MRIReco has been added.","category":"page"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There is a Jupyter-based tutorial on MRIReco at","category":"page"},{"location":"","page":"Home","title":"Home","text":"https://github.com/MagneticResonanceImaging/MRIRecoTutorial","category":"page"},{"location":"","page":"Home","title":"Home","text":"that has been presented at the ISMRM conference in Montreal 2019. Since the API has slightly changed, we, however recommend that you read this documentation and in particular execute the example scripts as is described in the Getting Started section.","category":"page"},{"location":"filehandling/#File-Handling","page":"File Handling","title":"File Handling","text":"","category":"section"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"MRI Acquisition Data can not only be generated from simulation but also from files. Currently, MRIReco supports the ISMRMRD file format the Bruker file format (at least partially).","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"The ISMRMRD is fully supported with proper read and write support. For the Bruker file format only reading of data is supported.","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"The example discussed in the following can be run by entering","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"include(joinpath(dirname(pathof(MRIReco)),\"../docs/src/examples/exampleIO.jl\"))","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"into the Julia REPL.","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"We start by loading a file handle to a Bruker dataset using","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"f = BrukerFile(\"brukerfileCart\")","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"This file handle does not yet contain the data. To load the data we call","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"raw = RawAcquisitionData(f)","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"which will load all data that can be encoded into a RawAcquisitionData object. For reconstruction we can then convert it to the preprocessed data format and call","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"acq = AcquisitionData(raw)\n\nparams = Dict{Symbol, Any}()\nparams[:reco] = \"direct\"\nparams[:reconSize] = (acq.encodingSize[1],acq.encodingSize[2])\n\nimg = reconstruction(acq, params)","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"This will result in the following image:","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"(Image: BrukerReco)","category":"page"},{"location":"filehandling/#Saving","page":"File Handling","title":"Saving","text":"","category":"section"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"But loading the data is only one important operation. Lets suppose that you have performed an expensive simulation resulting in a raw data object raw. To store this data one can simply run","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"fout = ISMRMRDFile(\"outputfile.h5\")\nsave(fout, raw)","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"which will generate an ISMRMRD file containing the data.","category":"page"},{"location":"filehandling/#Conversion","page":"File Handling","title":"Conversion","text":"","category":"section"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"It should now be no surprise that MRIReco.jl does also allow for file conversion:","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"f = BrukerFile(\"brukerfileCart\")\nraw = RawAcquisitionData(f)\nfout = ISMRMRDFile(\"outputfile.h5\")\nsave(fout, raw)","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"Currently, this is only limited to converting Bruker files into ISMRMRD files but the infrastructure is not limited to that.","category":"page"}]
}
