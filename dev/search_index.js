var documenterSearchIndex = {"docs":
[{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"EditURL = \"../../../lit/examples/01-binning.jl\"","category":"page"},{"location":"generated/examples/01-binning/#binning","page":"Binning","title":"Binning","text":"","category":"section"},{"location":"generated/examples/01-binning/#Description","page":"Binning","title":"Description","text":"","category":"section"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"This example described how to perform data binning with different number of profiles which is generaly used for self-gating acquisition in order to reconstruct images along the cardiac/respiratory cycle :","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"Trotier AJ, Castets CR, Lefrançois W, et al. USPIO-enhanced 3D-cine self-gated cardiac MRI based on a stack-of-stars golden angle short echo time sequence: Application on mice with acute myocardial infarction. Journal of Magnetic Resonance Imaging 2016;44:355–365 doi: 10.1002/jmri.25150.\nRibot EJ, Duriez TJ, Trotier AJ, Thiaudiere E, Franconi J-M, Miraux S. Self-gated bSSFP sequences to detect iron-labeled cancer cells and/or metastases in vivo in mouse liver at 7 Tesla. Journal of Magnetic Resonance Imaging 2015;41:1413–1421 doi: 10.1002/jmri.24688.","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"Here, we will create a simulated 2D radial acquisition and split the projections in 2 parts along the contrast dimension. The number of projection into each bin will be different to show how MRIReco handle that case.","category":"page"},{"location":"generated/examples/01-binning/#Setup","page":"Binning","title":"Setup","text":"","category":"section"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"using CairoMakie\nusing ImageUtils: shepp_logan\nusing MRIReco, MRISimulation\n\nfunction plot_im2D(im2D;title::String=\"\")\n    f = Figure()\n    ax = Axis(f[1, 1],aspect = DataAspect(), yreversed = true, title = title)\n    image!(ax, im2D')\n    hidedecorations!(ax, grid = false)\n    f\nend","category":"page"},{"location":"generated/examples/01-binning/#Simulate-a-radial-acquisition","page":"Binning","title":"Simulate a radial acquisition","text":"","category":"section"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"N = 256\nx = shepp_logan(N)\n\nparams = Dict{Symbol, Any}()\nparams[:simulation] = \"fast\"\nparams[:trajName] = \"Radial\"\nparams[:numProfiles] = round(Int64,400)\nparams[:numSamplingPerProfile] = round(Int64,N)\n\nacqRad = simulation(x, params)\nrawRad = RawAcquisitionData(acqRad)","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"For real acquisition we first create the RawAcquisitionData structure and then convert into the AcquisitionData.","category":"page"},{"location":"generated/examples/01-binning/#Binning-Data","page":"Binning","title":"Binning Data","text":"","category":"section"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"rawRad2 = deepcopy(rawRad)\nfor i in 1:length(rawRad.profiles)\n    if  mod(i,4) == 0\n        rawRad2.profiles[i].head.idx.contrast = 0\n    else\n        rawRad2.profiles[i].head.idx.contrast = 1\n    end\nend;\nnothing #hide","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"We need to tell to MRIReco that our trajectory is a custom one :","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"rawRad2.params[\"trajectory\"] = \"custom\";\nnothing #hide","category":"page"},{"location":"generated/examples/01-binning/#Reconstruction","page":"Binning","title":"Reconstruction","text":"","category":"section"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"To perform the reconstruction we need to convert the RawAcquisitionData into and AcquisitionData structure.","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"acqRad2 = AcquisitionData(rawRad2)","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"We can also plot the number of projection for both bin :","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"nPro1 = Int32(length(acqRad2.kdata[1,1,1])/N)\nnPro2 = Int32(length(acqRad2.kdata[2,1,1])/N)\nprintln(\"Number of projection in : \\n\n- Bin 1 = $nPro1\\n\n- Bin 2 = $nPro2\")","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"Now we can perform a standard reconstruction","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"params = Dict{Symbol, Any}()\nparams[:reco] = \"direct\"\nparams[:reconSize] = (N,N)\n\nIreco = reconstruction(acqRad2, params)\nsize(Ireco)","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"let's show the results for first bin","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"plot_im2D(abs.(Ireco[:,:,1,1]),title = \"First bin\")","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"and the second bin","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"plot_im2D(abs.(Ireco[:,:,1,2]),title = \"Second bin\")","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"As expected we have more streaking artifacts on the first bin because we reconstruct the image with less projections.","category":"page"},{"location":"generated/examples/01-binning/#Reproducibility","page":"Binning","title":"Reproducibility","text":"","category":"section"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"This page was generated with the following version of Julia:","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"using InteractiveUtils\nio = IOBuffer();\nversioninfo(io);\nsplit(String(take!(io)), '\\n')","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"And with the following package versions","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"import Pkg; Pkg.status()","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"","category":"page"},{"location":"generated/examples/01-binning/","page":"Binning","title":"Binning","text":"This page was generated using Literate.jl.","category":"page"},{"location":"acquisitionData/#Acquisition-Data","page":"Acquisition Data","title":"Acquisition Data","text":"","category":"section"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"There are two different forms of acquisition data types in MRIReco:","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"RawAcquisitionData\nAcquisitionData","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"While the former is used to hold the data in the form, how it will be written out from the scanner, the later has already performed some data permutations bringing the data into the shape how the reconstruction expects it.","category":"page"},{"location":"acquisitionData/#Raw-Data","page":"Acquisition Data","title":"Raw Data","text":"","category":"section"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"The RawAcquisitionData is a data type that closely resembles the ISMRMRD data format. It looks like","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"mutable struct RawAcquisitionData\n  params::Dict{String, Any}\n  profiles::Vector{Profile}\nend","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"with","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"mutable struct Profile\n  head::AcquisitionHeader\n  traj::Array{Float32,2}\n  data::Array{Complex{Float32},2}\nend","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"The params member of RawAcquisitionData is basically a flattened dictionary derived from the XML part of an ISMRMRD file. A Profile describes the data measured after a single excitation during an MRI experiment. It has members head, traj, and data, which exactly resemble the structures specified by the ISMRMRD file format.","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"AcquisitionHeader has exactly the same structure as ISMRMRD. You can find more information about it here","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"Two fields are especially important in it :","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"flags\nidx","category":"page"},{"location":"acquisitionData/#flags","page":"Acquisition Data","title":"flags","text":"","category":"section"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"The flags field in the AcquisitionHeader is a 64 bit mask that can be used to indicate specific attributes of the corresponding readout. One usage of these flags is to reverse the signal during conversion from RawAcquisitionData to AcquisitionData if the flag \"ACQISREVERSE\" is set.","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"FLAGS = Dict(\n    \"ACQ_FIRST_IN_ENCODE_STEP1\"                => 1,\n    \"ACQ_LAST_IN_ENCODE_STEP1\"                 => 2,\n    \"ACQ_FIRST_IN_ENCODE_STEP2\"                => 3,\n    \"ACQ_LAST_IN_ENCODE_STEP2\"                 => 4,\n    \"ACQ_FIRST_IN_AVERAGE\"                     => 5,\n    \"ACQ_LAST_IN_AVERAGE\"                      => 6,\n    \"ACQ_FIRST_IN_SLICE\"                       => 7,\n    \"ACQ_LAST_IN_SLICE\"                        => 8,\n    \"ACQ_FIRST_IN_CONTRAST\"                    => 9,\n    \"ACQ_LAST_IN_CONTRAST\"                     => 10,\n    \"ACQ_FIRST_IN_PHASE\"                       => 11,\n    \"ACQ_LAST_IN_PHASE\"                        => 12,\n    \"ACQ_FIRST_IN_REPETITION\"                  => 13,\n    \"ACQ_LAST_IN_REPETITION\"                   => 14,\n    \"ACQ_FIRST_IN_SET\"                         => 15,\n    \"ACQ_LAST_IN_SET\"                          => 16,\n    \"ACQ_FIRST_IN_SEGMENT\"                     => 17,\n    \"ACQ_LAST_IN_SEGMENT\"                      => 18,\n    \"ACQ_IS_NOISE_MEASUREMENT\"                 => 19,\n    \"ACQ_IS_PARALLEL_CALIBRATION\"              => 20,\n    \"ACQ_IS_PARALLEL_CALIBRATION_AND_IMAGING\"  => 21,\n    \"ACQ_IS_REVERSE\"                           => 22,\n    \"ACQ_IS_NAVIGATION_DATA\"                   => 23,\n    \"ACQ_IS_PHASECORR_DATA\"                    => 24,\n    \"ACQ_LAST_IN_MEASUREMENT\"                  => 25,\n    \"ACQ_IS_HPFEEDBACK_DATA\"                   => 26,\n    \"ACQ_IS_DUMMYSCAN_DATA\"                    => 27,\n    \"ACQ_IS_RTFEEDBACK_DATA\"                   => 28,\n    \"ACQ_IS_SURFACECOILCORRECTIONSCAN_DATA\"    => 29,\n    \"ACQ_COMPRESSION1\"                         => 53,\n    \"ACQ_COMPRESSION2\"                         => 54,\n    \"ACQ_COMPRESSION3\"                         => 55,\n    \"ACQ_COMPRESSION4\"                         => 56,\n    \"ACQ_USER1\"                                => 57,\n    \"ACQ_USER2\"                                => 58,\n    \"ACQ_USER3\"                                => 59,\n    \"ACQ_USER4\"                                => 60,\n    \"ACQ_USER5\"                                => 61,\n    \"ACQ_USER6\"                                => 62,\n    \"ACQ_USER7\"                                => 63,\n    \"ACQ_USER8\"                                => 64\n)","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"You can check the flags of a profile with flags_of(p:Profile OR head::AcquisitionHeader) or flag_is_set and manipulate them with thus functions :","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"flag_set!(obj::Profile, flag)\nflag_remove!(obj::Profile, flag)\nflag_remove_all!(obj::Profile)","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"Thus functions can also been directly applied to the AcquisitionHeader and you can set! or remove! multiple flags at once :","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"flag_set!(head::AcquisitionHeader, [FLAGS[\"ACQ_USER8\"], FLAGS[\"ACQ_IS_REVERSE\"]])\n# OR\nflag_set!(head::AcquisitionHeader, [FLAGS[\"ACQ_USER8\"],FLAGS[\"ACQ_IS_REVERSE\"]])","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"Alternatively, you can set the flags directly with specific Const variable :","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"h = AcquisitionHeader()\nh.flags = ACQ_IS_PARALLEL_CALIBRATION | ACQ_IS_NOISE_MEASUREMENT\nflags_of(h)\nh.flags = h.flags & ~ACQ_IS_NOISE_MEASUREMENT # remove the flag ACQ_IS_NOISE_MEASUREMENT\nflags_of(h)","category":"page"},{"location":"acquisitionData/#idx","page":"Acquisition Data","title":"idx","text":"","category":"section"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"MR acquisitions often loop through a set of counters (e.g. phase encodes) in a complete experiment. The following encoding counters are referred to by the idx field in the AcquisitionHeader (See the ISMRMRD documentation)","category":"page"},{"location":"acquisitionData/#Preprocessed-Data","page":"Acquisition Data","title":"Preprocessed Data","text":"","category":"section"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"The RawAcquisitionData can be preprocessed into a form, which makes it more convenient for reconstruction algorithms. The AcquisitionData type looks like","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"mutable struct AcquisitionData\n  sequenceInfo::Dict{Symbol,Any}\n  traj::Vector{Trajectory}\n  kdata::Array{Matrix{ComplexF64},3}\n  subsampleIndices::Vector{Array{Int64}}\n  encodingSize::Vector{Int64}\n  fov::Vector{Float64}\nend","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"It consists of the sequence informations stored in a dictionary, the k-space trajectory, the k-space data, and several parameters describing the dimension of the data and some additional index vectors.","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"The k-space data kdata has three dimensions encoding","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"dim : contrasts/echoes\ndim : slices\ndim : repetitions","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"Each element is a matrix encoding","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"dim : k-space nodes\ndim : channels/coils","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"In case of undersampled data, the subsampling indices are stored in subsampleIndices. One check if the data is undersampled by checking if isempty(subsampleIndices).","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"The encoded space is stored in the field encodingSize. It is especially relevant for non-Cartesian trajectories where it is not clear upfront, how large the grid size for reconstruction should be chosen. Finally fov describes the physical lengths of the encoding grid.","category":"page"},{"location":"acquisitionData/#Manipulating-rawData","page":"Acquisition Data","title":"Manipulating rawData","text":"","category":"section"},{"location":"acquisitionData/#Extract-a-subset-of-profiles-with-flags","page":"Acquisition Data","title":"Extract a subset of profiles with flags","text":"","category":"section"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"A subset of rawData can be extracted according to the flags using the function filter_raw_by_flags. For example this function can be used to extract :","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"Noise : raw_noise = filter_raw_by_flags(raw,\"ACQ_IS_NOISE_MEASUREMENT\")\nExtract calibration data : raw_noise = filter_raw_by_flags(raw,[\"ACQ_IS_PARALLEL_CALIBRATION_AND_IMAGING\",\"ACQ_IS_PARALLEL_CALIBRATION\"])","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"If you want to retrieve the data without the noise and calibration data you can use the following command :","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"raw = remove_raw_by_flags(raw,[\"ACQ_IS_NOISE_MEASUREMENT\",\"ACQ_IS_PARALLEL_CALIBRATION_AND_IMAGING\",\"ACQ_IS_PARALLEL_CALIBRATION\"])","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"by default the following flags are removed :","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"\"ACQ_IS_NOISE_MEASUREMENT\", \n\"ACQ_IS_PARALLEL_CALIBRATION\", \n\"ACQ_IS_NAVIGATION_DATA\", \n\"ACQ_IS_PHASECORR_DATA\", \n\"ACQ_IS_DUMMYSCAN_DATA\", \n\"ACQ_IS_PHASE_STABILIZATION_REFERENCE\", \"ACQ_IS_PHASE_STABILIZATION\"","category":"page"},{"location":"acquisitionData/#Pre-processing-tools","page":"Acquisition Data","title":"Pre-processing tools","text":"","category":"section"},{"location":"acquisitionData/#Remove-readout-oversampling","page":"Acquisition Data","title":"Remove readout oversampling","text":"","category":"section"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"On clinical MR scanners, the raw data are often oversampled in the readout direction. This oversampling is not necessary for image reconstruction and can be removed to save memory and computation time. This step is generally applied right after the acquisition of each line. The current implementation is performed on the RawAcquisitionData (before conversion to AcquisitionData) and is based on the following parameters:","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"rawData.params[\"encodedFOV\"][1]\nrawData.params[\"reconFOV\"][1]","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"If an oversampling factor of 2 is applied during acquisition, the encodedFOV will be 2 times larger than reconFOV along the readout dimension.","category":"page"},{"location":"acquisitionData/","page":"Acquisition Data","title":"Acquisition Data","text":"!!! note\n    Be careful to remove all the profiles from a `RawAcquisitionData` that are not supposed to be of the same size; like noise acquisition or navigators. You can use the function `raw = remove_raw_by_flags(raw)`.","category":"page"},{"location":"trajectories/#Trajectory","page":"Trajectory","title":"Trajectory","text":"","category":"section"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"Several typical MRI k-space trajectories are available:","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"Cartesian\nEPI\nRadial\nSpiral","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"In addition, it is also possible to define new k-space trajectories. Currently, most of the trajectories are only available in 2D. Each trajectory is of type Trajectory and implements the following functions","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"string(tr::Trajectory)\nkspaceNodes(tr::Trajectory)\nreadoutTimes(tr::Trajectory)","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"For instance we can define a spiral, radial, and cartesian trajectory using","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"tr = trajectory(\"Spiral\", 1, 600, windings=10)\ntr = trajectory(\"Cartesian\", 13, 50, EPI_factor=1)\ntr = trajectory(\"Radial\", 13, 50)","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"A variable density spiral can be generated by","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"tr = trajectory(\"SpiralVarDens\", 3, 200)","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"The k-space nodes can then be accessed by","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"nodes = kspaceNodes(tr)","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"The script generating the following image can be executed by running the following from within the Julia REPL:","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"include(joinpath(dirname(pathof(MRIReco)),\"../docs/src/examples/exampleTrajectories.jl\"))","category":"page"},{"location":"trajectories/","page":"Trajectory","title":"Trajectory","text":"(Image: Trajectories)","category":"page"},{"location":"compressedSensing/#Compressed-Sensing","page":"Compressed Sensing","title":"Compressed Sensing","text":"","category":"section"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"We next consider a compressed sensing reconstruction using one slice of a knee dataset obtained from mridata.org. The example can be run by entering","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"include(joinpath(dirname(pathof(MRIReco)),\"../docs/src/examples/exampleCS.jl\"))","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"into the Julia REPL.","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"We first perform a baseline reconstruction with fully sampled data:","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"# load fully sampled data\nf = ISMRMRDFile(\"data/knee_3dFSE_slice170.h5\")\nacqData = AcquisitionData(f);\n\n# reconstruct\nparams = Dict{Symbol, Any}()\nparams[:reco] = \"direct\"\nparams[:reconSize] = (320,320) # this size is also contained in acqData.encodingSize\n\nimg = reconstruction(acqData, params)\nimg = sqrt.(sum(img.^2,dims=5))","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"The result looks like this:","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"(Image: Knee Original)","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"To simulate an undersampled reconstruction, we retrospectively undersample the data using a Poisson disk pattern.","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"redFac = 4.0\nacqDataSub = sample_kspace(acqData,redFac,\"poisson\",calsize=30,profiles=false);","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"The sampling pattern looks like this:","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"(Image: Mask)","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"Then, we estimate the coil sensitivities using ESPIRiT","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"smaps = espirit(acqData,(6,6),30,eigThresh_1=0.035,eigThresh_2=0.98)","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"and perform a simple SENSE reconstruction. We expect a degradation in image quality due to the subsampling:","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"params = Dict{Symbol, Any}()\nparams[:reco] = \"multiCoil\"\nparams[:reconSize] = (320,320)\nparams[:senseMaps] = smaps\n\nparams[:solver] = CGNR\nparams[:reg] = L2Regularization(1.e-4)\nparams[:iterations] = 5\nparams[:normalizeReg] = MeasurementBasedNormalization()\n\nimg_cg = reconstruction(acqDataSub, params)","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"Using TV regularization recquires us to change some parameters:","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"params = Dict{Symbol, Any}()\nparams[:reco] = \"multiCoil\"\nparams[:reconSize] = (320,320)\nparams[:senseMaps] = smaps\n\nparams[:solver] = ADMM\nparams[:reg] = TVRegularization(1.e-1, shape = (320, 320))\nparams[:iterations] = 50\nparams[:ρ] = 0.1\nparams[:absTol] = 1.e-4\nparams[:relTol] = 1.e-2\nparams[:tolInner] = 1.e-2\nparams[:normalizeReg] = MeasurementBasedNormalization()\n\nimg_tv = reconstruction(acqDataSub, params)","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"Lets compare the results, left the regular SENSE reconstruction and right the TV reglarized solution:","category":"page"},{"location":"compressedSensing/","page":"Compressed Sensing","title":"Compressed Sensing","text":"(Image: SENSE) (Image: TV)","category":"page"},{"location":"image/#Images","page":"Images","title":"Images","text":"","category":"section"},{"location":"image/","page":"Images","title":"Images","text":"All reconstructed data is stored as an AxisArray. The AxisArrays package is part of the Images package family, which groups all image processing related functionality together. We note that the term Image does not restrict the dimensionality of the data types to 2D but in fact images can be of arbitrary dimensionality.","category":"page"},{"location":"image/","page":"Images","title":"Images","text":"The reconstructed MRI image I is an AxisArray and has five dimensions. The first three are the spatial dimension x, y, and z, whereas dimension four encodes the number of echos that have been reconstructed, while dimension five encodes individual coils that may have been reconstructed independently. By using an AxisArray the object does not only consist of the data but it additionally encodes the physical size of the image as well as the echo times. To extract the ordinary Julia array one can simply use Ireco.data.","category":"page"},{"location":"image/","page":"Images","title":"Images","text":"The advantage of encoding the physical dimensions is the image data can be stored without loosing the dimensions of the data. For instance one can call","category":"page"},{"location":"image/","page":"Images","title":"Images","text":"saveImage(filename, I)","category":"page"},{"location":"image/","page":"Images","title":"Images","text":"to store the image and","category":"page"},{"location":"image/","page":"Images","title":"Images","text":"I = loadImage(filename)","category":"page"},{"location":"image/","page":"Images","title":"Images","text":"to load the image. Currently, MRIReco does support the NIfTI file format. By default, saveImage stores the data complex valued if the image I is complex valued. To store the magnitude image one can call","category":"page"},{"location":"image/","page":"Images","title":"Images","text":"saveImage(filename, I, true)","category":"page"},{"location":"offresonance/#Offresonance-Correction","page":"Offresonance","title":"Offresonance Correction","text":"","category":"section"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"For trajectories with long readouts the MRI images are degraded by offresonance artifacts, if the offresonance is not taken into account during reconstruction. We provide fast algorithms that are capable of correcting offresonance artifacts provided that the offresonance map is known. Our framework is also capable of correcting T2* relaxation effects. The later are encoded in the real part of the correction map while the offresoanance is encoded in the imaginary part. The following example shows an example of a simulation and reconstruction of MRI data that takes offresonance due to an inhomogeneous fieldmap into account. The example can be run by entering","category":"page"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"include(joinpath(dirname(pathof(MRIReco)),\"../docs/src/examples/exampleFieldmap.jl\"))","category":"page"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"into the Julia REPL.","category":"page"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"using MRIReco\n\nN = 256\nI = shepp_logan(N)\nI = circularShutterFreq!(I,1)\ncmap = 1im*quadraticFieldmap(N,N,125*2pi)\n\n# simulation parameters\nparams = Dict{Symbol, Any}()\nparams[:simulation] = \"fast\"\nparams[:trajName] = \"Spiral\"\nparams[:numProfiles] = 1\nparams[:numSamplingPerProfile] = N*N\nparams[:windings] = 128\nparams[:AQ] = 3.0e-2\nparams[:correctionMap] = cmap[:,:,1]\n\n# do simulation\nacqData = simulation(I, params)\n\n# reco parameters\nparams = Dict{Symbol, Any}()\nparams[:reco] = \"direct\"\nparams[:reconSize] = (N,N)\nparams[:correctionMap] = cmap\nparams[:alpha] = 1.75\nparams[:m] = 4.0\nparams[:K] = 28\n\n# do reconstruction\nIreco = reconstruction(acqData, params)","category":"page"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"The considered quadratic fieldmap looks like this:","category":"page"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"(Image: Fieldmap)","category":"page"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"The reconstruction without and with offresonance correction are shown below:","category":"page"},{"location":"offresonance/","page":"Offresonance","title":"Offresonance","text":"(Image: NoCorrection) (Image: Reconstruction)","category":"page"},{"location":"custom/#Customization","page":"Customize","title":"Customization","text":"","category":"section"},{"location":"custom/","page":"Customize","title":"Customize","text":"We promised that MRIReco allows for customization. Lets in the following consider a custom data-driven sparsifying transform that is currently not part of MRIReco.jl [S. Ravishankar and Y. Bresler, IEEE Trans. Med. Imaging, 30 (5), 2011].","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"It is based on","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"Learn a dictionary from a reference image (e.g. adjacent slice) using KSVD  colorgreencheckmark\nImplement sparsifying transform which analyses the input image in terms of the dictionary","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"(Image: DictTrafo)","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"In order to implement this, we first need the analyze function where we can reuse the matchingpursuit function from Wavelets.jl","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"function analyzeImage(x::Vector{T},D::Matrix{T},xsize::NTuple{2,Int64},\n                      psize::NTuple{2,Int64};t0::Int64=size(D,2),tol=1e-3) where T\n  nx,ny = xsize\n  px,py = psize\n  x = reshape(x,nx,ny)\n  x_pad = repeat(x,2,2)[1:nx+px-1,1:ny+py-1] # pad image using periodic boundary conditions\n  α = zeros(T,size(D,2),nx,ny)\n  patch = zeros(T,px*py)\n  for j=1:ny\n    for i=1:nx\n      patch[:] .= vec(x_pad[i:i+px-1,j:j+py-1])\n      norm(patch)==0 && continue\n      # matchingpursuit is contained in Wavelets.jl\n      α[:,i,j] .= matchingpursuit(patch, x->D*x, x->transpose(D)*x, tol)\n    end\n  end\n  return vec(α)\nend","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"Synthetization can be done by","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"function synthesizeImage(α::Vector{T},D::Matrix{T},xsize::NTuple{2,Int64},psize::NTuple{2,Int64}) where T\n  nx,ny = xsize\n  px,py = psize\n  x = zeros(T,nx+px-1,ny+py-1)\n  α = reshape(α,:,nx,ny)\n  for j=1:ny\n    for i=1:nx\n      x[i:i+px-1,j:j+py-1] .+= reshape(D*α[:,i,j],px,py)\n    end\n  end\n  return vec(x[1:nx,1:ny])/(px*py)\nend","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"Once we have those two operations we can setup up a dictionary operator:","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"function dictOp(D::Matrix{T},xsize::NTuple{2,Int64},psize::NTuple{2,Int64},tol::Float64=1.e-3) where T\n  produ = x->analyzeImage(x,D,xsize,psize,tol=tol)\n  ctprodu = x->synthesizeImage(x,D,xsize,psize)\n  return LinearOperator(prod(xsize)*size(D,2),prod(xsize),false,false\n          , produ\n          , nothing\n          , ctprodu )\nend","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"To test our method, let us load some simulated data and subsample it","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"# phantom\nimg = readdlm(\"data/mribrain100.tsv\")\n\nacqData = AcquisitionData(ISMRMRDFile(\"data/acqDataBrainSim100.h5\"))\nnx,ny = acqData.encodingSize\n\n# undersample kspace data\nacqData = sample_kspace(acqData, 2.0, \"poisson\", calsize=25,profiles=false);","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"Now we load a pre-trained dictionary, build the sparsifying transform and perform the reconstruction","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"# load the dictionary\nD = ComplexF64.(readdlm(\"data/brainDict98.tsv\"))\n\n# some parameters\npx, py = (6,6)  # patch size\nK = px*py       # number of atoms\n\n# CS reconstruction using Wavelets\nparams = Dict{Symbol,Any}()\nparams[:reco] = \"standard\"\nparams[:reconSize] = (nx,ny)\nparams[:iterations] = 50\nparams[:reg] = L1Regularization(2.e-2)\nparams[:sparseTrafo] = dictOp(D,(nx,ny),(px,py),2.e-2)\nparams[:ρ] = 0.1\nparams[:solver] = ADMM\nparams[:absTol] = 1.e-4\nparams[:relTol] = 1.e-2\n\nimg_d = reconstruction(acqData,params)","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"For comparison, let us perform the same reconstruction as above but with a Wavelet transform","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"delete!(params, :sparseTrafo)\nparams[:sparseTrafoName] = \"Wavelet\"\n\nimg_w = reconstruction(acqData,params)","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"The following pictures shows the wavelet based CS reconstruction on the left and the dictionary based CS reconstruction on the right:","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"(Image: BrainWavelet) (Image: BrainDict)","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"For reference, the original data is shown here:","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"(Image: BrainOrig)","category":"page"},{"location":"custom/","page":"Customize","title":"Customize","text":"One can clearly see that the dictionary approach performs better than a simple Wavelet L1 prior.","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"EditURL = \"../../../lit/examples/03-subspaceReconstruction.jl\"","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/#subspaceReconstruction","page":"Subspace","title":"Subspace","text":"","category":"section"},{"location":"generated/examples/03-subspaceReconstruction/#Description","page":"Subspace","title":"Description","text":"","category":"section"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"This example described how to perform a subspace reconstruction for T_2 mapping acceleration.","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/#Setup-and-define-global-variable","page":"Subspace","title":"Setup and define global variable","text":"","category":"section"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"using CairoMakie\nusing ImageUtils: shepp_logan\nusing LinearAlgebra\nusing  Random\nusing MRIReco, MRISimulation, MRICoilSensitivities, MRISampling,MRIOperators\nusing MRIReco.RegularizedLeastSquares\ncolor=Makie.wong_colors() # color for plots\n\nN = 128\nT = ComplexF32\nnCh = 4\nnEchos = 10\nTE = 7.0\n\n\n\nx = T.(shepp_logan(N))","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/#simulate-MESE-acquisition-of-a-shepp-logan-phantom","page":"Subspace","title":"simulate MESE acquisition of a shepp logan phantom","text":"","category":"section"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"First we need to simulate a multi-echo spin-echo phantom. The R₂ maps is based on the value of each voxel the shepp logan phantom. For the T2 we use","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"rmap = 0.05*abs.(x)\nTEnum = Float64.(collect(TE:TE:TE*nEchos))\n\ncoilsens = T.(birdcageSensitivity(N, nCh, 4.))\nparams = Dict{Symbol,Any}()\nparams[:simulation] = \"fast\"\nparams[:trajName] = \"Cartesian\"\nparams[:numProfiles] = floor(Int64, N)\nparams[:numSamplingPerProfile] = N\nparams[:r2map] = rmap\nparams[:T_echo] = TEnum\nparams[:seqName] = \"ME\"\nparams[:refocusingAngles] = Float64.(repeat([pi], length(TEnum)))\nparams[:senseMaps] = coilsens\n\nacqData = simulation(real(x), params)","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/#Subsampling-the-kspace","page":"Subspace","title":"Subsampling the kspace","text":"","category":"section"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"We need to subsample the data. We generate a sampling mask which is different for each TE.","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"mask = zeros(Int32,(N,N,length(TEnum)))\nfor echo = 1:length(TEnum)\n  mask_tmp = zeros(Int32,(N,N))\n  cal_disk = sample_poissondisk((N,N),4.0;calsize = 14,seed=echo)\n\n  mask_tmp[cal_disk] .= 1\n  mask[:,:,echo] = mask_tmp\nend\n\nf=Figure()\nax = Axis(f[1,1],title = \"mask TE n°1\")\nheatmap!(ax,mask[:,:,1])\nax = Axis(f[1,2],title = \"mask TE n°2\")\nheatmap!(ax,mask[:,:,2])\nf","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"Let's subsample the k-space in 2 different ways :","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"With the same mask along the temporal dimensions : acqData_u\nWith different masks along the temporal dimensions : acqData_u2","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"mask_multi2 = repeat(mask[:,:,1],1,1,1,nCh,nEchos,1);# same first mask along TE\n\nkspace = kDataCart(acqData);\nkspace = kspace .* mask_multi2;\nacqData_u = AcquisitionData(kspace);\n\nmask_multi = repeat(mask,1,1,1,nCh,1,1);\nmask_multi = permutedims(mask_multi,(1,2,5,4,3,6));\n\nkspace = kDataCart(acqData);\nkspace = kspace .* mask_multi;\nacqData_u2 = AcquisitionData(kspace);\nnothing #hide","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/#Reconstruction-of-undersampled-rawdata","page":"Subspace","title":"Reconstruction of undersampled rawdata","text":"","category":"section"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"params = Dict{Symbol,Any}()\nparams[:reconSize] = (N, N)\nparams[:reco] = \"multiCoilMultiEcho\"\nparams[:reg] = L2Regularization(1.e-3)\nparams[:iterations] = 1\nparams[:solver] = CGNR\nparams[:senseMaps] = reshape(coilsens, N, N, 1, nCh)\n\nim_x = reconstruction(acqData, params).data # fully reconstruction\nim_phant = abs.(im_x)\n\nim_x_u = reconstruction(acqData_u, params).data # undersampling same mask\nim_phant_u = abs.(im_x_u)\n\nim_x_u2 = reconstruction(acqData_u2, params).data # undersampling different mask along TE\nim_phant_u2 = abs.(im_x_u2)\n\np1 = (100, 45)\np2 = (40, 60)\necho=1\nf = Figure()\nax = Axis(f[1, 1], aspect=1, title=\"Fully\")\nhidedecorations!(ax)\nheatmap!(ax, im_phant[:, :, 1, echo, 1, 1])\nscatter!(ax, p1,color=color[4])\nscatter!(ax, p2,color=color[4])\n\nax = Axis(f[2, 1], aspect=1, title=\"CS same mask\")\nhidedecorations!(ax)\nheatmap!(ax, im_phant_u[:, :, 1, echo, 1, 1])\n\nax = Axis(f[3, 1], aspect=1, title=\"CS different masks\")\nhidedecorations!(ax)\nheatmap!(ax, im_phant_u2[:, :, 1, echo, 1, 1])\n\nax = Axis(f[:, 2],title = \"T2₁=$(round(1/rmap[p1...],digits=0)) | T2₂=$(round(1/rmap[p2...],digits=0)) ms\",xlabel = \"TE [ms]\",ylabel = \"MR signal\")\nlines!(ax, im_phant[p1..., 1, :, 1, 1],color=:black,label = \"fully\")\nlines!(ax, im_phant[p2..., 1, :, 1, 1],color=:black)\n\nlines!(ax, im_phant_u[p1..., 1, :, 1, 1],color=color[2],label = \"same mask\")\nlines!(ax, im_phant_u[p2..., 1, :, 1, 1],color=color[2],)\n\nlines!(ax, im_phant_u2[p1..., 1, :, 1, 1],color=color[3],label = \"different mask\")\nlines!(ax, im_phant_u2[p2..., 1, :, 1, 1],color=color[3])\naxislegend(ax)\nf","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"When the same mask is used along the temporal dimension, we see a standard decaying exponential curve. However the rate of decrease is biased by the PSF effect of the undersampling mask, corresponding by the same sum of others weigthed pixels.","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"When the mask is not the same along the temporal dimension, we observed a noisy curve close to the real exponential.","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/#Implementation-of-a-subspace-reconstruction","page":"Subspace","title":"Implementation of a subspace reconstruction","text":"","category":"section"},{"location":"generated/examples/03-subspaceReconstruction/#Build-the-dictionary","page":"Subspace","title":"Build the dictionary","text":"","category":"section"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"We build a signal dictionary using the analytical equation :","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"S(TE) = frac-TET2","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"with a range of T2 from 1:1:2000 ms","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"function createExpBasis(TE_vec::AbstractVector{T}, T2_vec::AbstractVector{T}) where {T<:Real}\n  nTE = length(TE_vec)\n  nSimu = length(T2_vec)\n  expSignal = zeros(T, nSimu, nTE)\n\n  for (i, T2) in enumerate(T2_vec)\n    expSignal[i, :] = exp.(-TE_vec / T2_vec[i])\n  end\n\n  return expSignal\nend\n\nT2_vec = (1:1:2000)\nsDict = createExpBasis(Float32.(TEnum), Float32.(T2_vec))","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"For real application with stimulated echo we have to remove the 1st echo from the dictionary and the rawdata","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/#Extract-the-subspace-temporal-basis","page":"Subspace","title":"Extract the subspace temporal basis","text":"","category":"section"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"Now we can perform an svd decomposition of the signal dictionnary in order to extract the temporal basis in order to use them during the reconstruction","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"svd_obj = svd(sDict)\nbasis = Complex.(svd_obj.V)[:, 1:5]","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"In this example, we will use the 5 first basis.","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"f=Figure()\nax = Axis(f[1,1])\nfor i = 1:size(basis,2)\n  lines!(ax,real.(svd_obj.V[:,i]))\nend\nf","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"Our supposition for the subspace reconstruction is that the MESE signal can be approximated by a linear combinaison of the 5 basis corresponding to the temporal curve.","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/#Subspace-reconstruction","page":"Subspace","title":"Subspace reconstruction","text":"","category":"section"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"In order to perform the subspace reconstruction we are using a dedicated pipeline name : params[:reco] = \"multiCoilMultiEchoSubspace\" and we also need to pass the basis params[:basis] = basis","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"Here, we also have added a Wavelet spatial regularization that will be applied on the basis coefficient maps.","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"params = Dict{Symbol,Any}()\nparams[:reconSize] = (N, N)\nparams[:reco] = \"multiCoilMultiEchoSubspace\"\n\nparams[:reg] = L1Regularization(0.001)\nparams[:sparseTrafo] = \"Wavelet\" #sparse trafo\nparams[:solver] = ADMM\nparams[:senseMaps] = reshape(coilsens, N, N, 1, nCh)\nparams[:basis] = basis\n\nparams[:iterations] = 1\nα = reconstruction(acqData, params)\nim_sub = abs.(applySubspace(α, basis))\n\nparams[:iterations] = 100\nα = reconstruction(acqData_u, params)\nim_sub_2 = abs.(applySubspace(α, basis))\n\nα = reconstruction(acqData_u2, params)\nim_sub_3 = abs.(applySubspace(α, basis));\nnothing #hide","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/#Coefficient-maps","page":"Subspace","title":"Coefficient maps","text":"","category":"section"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"The reconstruction returns the coefficient maps :","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"f = Figure()\nfor i = 1:size(basis,2)\n  ax = Axis(f[1,i],aspect=1,title = \"Basis n°$i\")\n  heatmap!(abs.(α[:,:,1,i,1,1]),colormap=:plasma)\n  hidedecorations!(ax)\nend\nf","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/#Virtual-echo-images","page":"Subspace","title":"Virtual echo images","text":"","category":"section"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"We need to multiply the subspace basis to the coefficient maps in order to get the virtual TE images","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"im_TE(ij) = sum_basis=1^5 alpha(ij) times basis","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"which gives the following results :","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"begin\np1 = (100, 45)\np2 = (40, 60)\necho = 1\nf = Figure()\nax = Axis(f[1, 1], aspect=1, title=\"Fully standard\")\nhidedecorations!(ax)\nheatmap!(ax, im_phant[:, :, 1, echo, 1, 1])\nscatter!(ax, p1,color=:red)\nscatter!(ax, p2,color=:red)\n\nax = Axis(f[1, 2], aspect=1, title=\"Fully with subspace reco\")\nhidedecorations!(ax)\nheatmap!(ax, im_sub[:, :, 1, echo, 1, 1])\n\nax = Axis(f[1, 3], aspect=1, title=\"CS same mask\")\nhidedecorations!(ax)\nheatmap!(ax, im_sub_2[:, :, 1, echo, 1, 1])\n\nax = Axis(f[1, 4], aspect=1, title=\"CS different masks\")\nhidedecorations!(ax)\nheatmap!(ax, im_sub_3[:, :, 1, 1, 1, 1])\n\nax = Axis(f[2, :],title = \"T2₁=$(round(1/rmap[p1...],digits=0)) | T2₂=$(round(1/rmap[p2...],digits=0)) ms\",xlabel = \"TE [ms]\",ylabel = \"MR signal\")\nfunction scale_T2(T2vect)\n  return T2vect/T2vect[1]\nend\nlines!(ax, scale_T2(im_phant[p1..., 1, :, 1, 1]),color=:black,label = \"fully\")\nlines!(ax, scale_T2(im_phant[p2..., 1, :, 1, 1]),color=:black)\n\nlines!(ax, scale_T2(im_sub[p1..., 1, :, 1, 1]),color=color[1],label = \"fully subspace\")\nlines!(ax, scale_T2(im_sub[p2..., 1, :, 1, 1]),color=color[1])\n\nlines!(ax, scale_T2(im_sub_2[p1..., 1, :, 1, 1]),color=color[2],label = \"same mask\")\nlines!(ax, scale_T2(im_sub_2[p2..., 1, :, 1, 1]),color=color[2])\n\nlines!(ax, scale_T2(im_sub_3[p1..., 1, :, 1, 1]),color=color[3],label = \"different mask\")\nlines!(ax, scale_T2(im_sub_3[p2..., 1, :, 1, 1]),color=color[3])\naxislegend(ax)\nf\nend","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/#Reproducibility","page":"Subspace","title":"Reproducibility","text":"","category":"section"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"This page was generated with the following version of Julia:","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"using InteractiveUtils\nio = IOBuffer();\nversioninfo(io);\nsplit(String(take!(io)), '\\n')","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"And with the following package versions","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"import Pkg; Pkg.status()","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"","category":"page"},{"location":"generated/examples/03-subspaceReconstruction/","page":"Subspace","title":"Subspace","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"EditURL = \"../../../lit/examples/02-extractKspace.jl\"","category":"page"},{"location":"generated/examples/02-extractKspace/#extractKspace","page":"Extract k-space","title":"Extract k-space","text":"","category":"section"},{"location":"generated/examples/02-extractKspace/#Description","page":"Extract k-space","title":"Description","text":"","category":"section"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"This example described how to extract kspace from cartesian datasets, undersample the data and create back and AcquisitionData structure that can be used for reconstruction.","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"This possibility can be easily combined with the BartIO package to reconstruct the kspace.","category":"page"},{"location":"generated/examples/02-extractKspace/#Setup","page":"Extract k-space","title":"Setup","text":"","category":"section"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"using CairoMakie\nusing ImageUtils: shepp_logan\nusing MRIReco, MRISimulation\nusing InteractiveUtils: versioninfo\n\nfunction plot_im2D(im2D;title::String=\"\")\n    f = Figure()\n    ax = Axis(f[1, 1],aspect = DataAspect(), yreversed = true, title = title)\n    image!(ax, im2D')\n    hidedecorations!(ax, grid = false)\n    f\nend","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"Let's create a non-square AcquisitionData structure and perform a standard reconstruction","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"N = 128\nN2 = 96","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"image","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"x = shepp_logan(N)","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"simulation","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"params = Dict{Symbol, Any}()\nparams[:simulation] = \"fast\"\nparams[:trajName] = \"Cartesian\"\nparams[:numSamplingPerProfile] = N\nparams[:numProfiles] = floor(Int64, N2)\n\nacqData = simulation(x[1:N,1:N2], params)\n\nparams[:reco] = \"direct\"\nparams[:reconSize] = (N,N2)\n\nx_approx = reconstruction(acqData, params);\nnothing #hide","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"let's show the results for first bin","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"plot_im2D(abs.(x_approx[:,:,1,1,1,1]),title = \"Reco from AcquisitionData\")","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"We can extract the cartesian kspace (works for 2D or 3D) with the function kDataCart","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"kspace = kDataCart(acqData)\nsize(kspace)","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"Dimensions of the kspace are : kx, ky, kz, Channels, Echoes, Repetitions","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"Let's see a standard reconstruction with the ifft function works :","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"x_approx2 = ifftshift(ifft(ifftshift(kspace)))\nplot_im2D(abs.(x_approx2[:,:,1,1,1,1]),title = \"Reco from extracted kspace\")","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"We can create create and apply a mask on the kspace","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"mask = ones(eltype(kspace),size(kspace))\nmask[1:2:end,:,:,:,:,:] .= 0\nacq_u = AcquisitionData(kspace .* mask)\nparams[:reco] = \"direct\"\nparams[:reconSize] = (N,N2)\n\nx_u = reconstruction(acq_u, params)\nplot_im2D(abs.(x_u[:,:,1,1,1,1]),title = \"Reco from undersampled AcquisitionData\")","category":"page"},{"location":"generated/examples/02-extractKspace/#Reproducibility","page":"Extract k-space","title":"Reproducibility","text":"","category":"section"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"This page was generated with the following version of Julia:","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"using InteractiveUtils\nio = IOBuffer();\nversioninfo(io);\nsplit(String(take!(io)), '\\n')","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"And with the following package versions","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"import Pkg; Pkg.status()","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"","category":"page"},{"location":"generated/examples/02-extractKspace/","page":"Extract k-space","title":"Extract k-space","text":"This page was generated using Literate.jl.","category":"page"},{"location":"gettingStarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"Throughout the entire documentation we assume that you have loaded MRIReco as well as CairoMakie via","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"using CairoMakie, MRIReco","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"All examples discussed in the documentation can be found in the package source code in the folder","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"    MRIReco/docs/src/examples","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"This folder is located in ~/.julia/packages or ~/.julia/dev depending if you have checked out MRIReco for development or not. You can call the first example by entering into the Julia REPL:","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"include(joinpath(dirname(pathof(MRIReco)),\"../docs/src/examples/exampleRadial.jl\"))","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"which should open a plotting window as is outlined in the following example.","category":"page"},{"location":"gettingStarted/#Basic-Example","page":"Getting Started","title":"Basic Example","text":"","category":"section"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"We will start with a very simple example and perform simple simulation and reconstruction based on a shepp logan phantom. The program looks like this","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"# image\nN = 256\nI = shepp_logan(N)\n\n# simulation parameters\nparams = Dict{Symbol, Any}()\nparams[:simulation] = \"fast\"\nparams[:trajName] = \"Radial\"\nparams[:numProfiles] = floor(Int64, pi/2*N)\nparams[:numSamplingPerProfile] = 2*N\n\n# do simulation\nacqData = simulation(I, params)\n\n# reco parameters\nparams = Dict{Symbol, Any}()\nparams[:reco] = \"direct\"\nparams[:reconSize] = (N,N)\nIreco = reconstruction(acqData, params)","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"We will go through the program step by step. First we create a 2D shepp logan phantom of size N=256. Then we setup a dictionary that defines the simulation parameters. Here, we chose a simple radial trajectory with 402 spokes and 512 samples per profile. We use a gridding-based simulator by setting params[:simulation] = \"fast\"","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"After setting up the parameter dictionary params, the simulation is performed by calling","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"acqData = simulation(I, params)","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"The result simulation function outputs an acquisition object that is discussed in more detail in the section Acquisition Data. The acquisition data can also be stored to or loaded from a file, which will be discussed in section File Handling.","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"Using the acquisition data we can perform a reconstruction. To this end, again a parameter dictionary is setup and some basic configuration is done. In this case, for instance we specify that we want to apply a simple NFFT-based gridding reconstruction. The reconstruction is invoked by calling","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"Ireco = reconstruction(acqData, params)","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"The resulting image is of type AxisArray and has 5 dimensions. One can display the image object by calling","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"heatmap(abs.(Ireco[:,:,1,1,1]))","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"Alternatively one can store the image into a file, which will be discussed in the section on Images.","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"The original phantom and the reconstructed image are shown below","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: Phantom) (Image: Reconstruction)","category":"page"},{"location":"gettingStarted/","page":"Getting Started","title":"Getting Started","text":"We will discuss reconstruction in more detail in the sections on Offresonance Correction, Parallel Imaging, and Compressed Sensing","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"This page contains documentation of the public API of MRIReco. In the Julia REPL one can access this documentation by entering the help mode with ? and then writing the function for which the documentation should be shown.","category":"page"},{"location":"API/#Operators","page":"API","title":"Operators","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Operators are implemented as subtypes of AbstractLinearOperator, which is defined in the package LinearOperators.jl. Such operators must provide a function implementing the product and a function implementing the product with the adjoint. Furthermore, the number of rows and columns of the operator must be specified.","category":"page"},{"location":"API/","page":"API","title":"API","text":"MRIReco.EncodingOp\nMRIReco.lrEncodingOp\nMRIReco.fourierEncodingOp\nMRIReco.encodingOps_simple\nMRIReco.encodingOps_parallel\nMRIReco.encodingOp_multiEcho\nMRIReco.encodingOp_multiEcho_parallel\nMRIReco.fourierEncodingOp\nMRIReco.ExplicitOp(shape::NTuple{D,Int64}, tr::Trajectory{T}, correctionmap::AbstractArray{Tc,D}\n                        ; echoImage::Bool=false, S = storage_type(correctionmap), kargs...) where {T, Tc <: Union{Complex{T}, T}, D}\nMRIReco.SubspaceOp\nMRIReco.FFTop                   \nMRIReco.NFFTOp\nMRIReco.FieldmapNFFTOp\nMRIReco.SamplingOp\nMRIReco.SensitivityOp\nMRIReco.SparseOp\nMRIReco.RegularizedLeastSquares.WeightingOp","category":"page"},{"location":"API/#Datatypes","page":"API","title":"Datatypes","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"MRIReco.AcquisitionData\nMRIReco.AcquisitionData(tr::T,kdata::Array{Matrix{ComplexF64},3}\n                        ; seqInfo=Dict{Symbol,Any}()\n                        , idx=nothing\n                        , encodingSize=Int64[0,0,0]\n                        , fov=Float64[0,0,0]\n                        , kargs...) where T <: Union{Trajectory,Vector{Trajectory}}\nMRIReco.trajectory(acqData::AcquisitionData,i::Int64=1)\nMRIReco.numContrasts(acqData::AcquisitionData)\nMRIReco.numChannels\nMRIReco.numSlices\nMRIReco.numRepetitions\nMRIReco.kData\nMRIReco.multiEchoData\nMRIReco.multiCoilData\nMRIReco.multiCoilMultiEchoData\nMRIReco.profileData\nMRIReco.samplingDensity\nMRIReco.changeEncodingSize2D\nMRIReco.convert3dTo2d\nMRIReco.RawAcquisitionData\nMRIReco.trajectory(f::RawAcquisitionData; slice::Int=1, contrast::Int=1)\nMRIReco.rawdata(f::RawAcquisitionData)\nMRIReco.AcquisitionData(f::RawAcquisitionData)\nMRIReco.RawAcquisitionData(f::ISMRMRDFile, dataset=\"dataset\")\nMRIReco.AcquisitionData(f::ISMRMRDFile, dataset=\"dataset\")","category":"page"},{"location":"API/#Trajectories","page":"API","title":"Trajectories","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"MRIReco.Trajectory\nMRIReco.trajectory(trajName::AbstractString, numProfiles::Int, numSamplingPerProfile::Int; MRIReco.numSlices::Int64=1, TE::Float64=0.0, AQ::Float64=1.e-3, kargs...)\nMRIReco.string(tr::Trajectory)\nMRIReco.echoTime(tr::Trajectory)\nMRIReco.acqTimePerProfile(tr::Trajectory)\nMRIReco.numProfiles(tr::Trajectory)\nMRIReco.numSamplingPerProfile(tr::Trajectory)\nMRIReco.numSlices(tr::Trajectory)\nMRIReco.isCircular(tr::Trajectory)\nMRIReco.isCartesian(tr::Trajectory)\nMRIReco.dims(tr::Trajectory)\nMRIReco.kspaceNodes(tr::Trajectory)\nMRIReco.readoutTimes(tr::Trajectory)\nMRIReco.CartesianTrajectory\nMRIReco.EPITrajectory\nMRIReco.OneLine2dTrajectory\nMRIReco.RadialTrajectory\nMRIReco.SpiralTrajectory\nMRIReco.SpiralTrajectoryVarDens\nMRIReco.CartesianTrajectory3D\nMRIReco.KooshballTrajectory\nMRIReco.StackOfStarsTrajectory","category":"page"},{"location":"API/#Sequences","page":"API","title":"Sequences","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"MRIReco.MESequence\nMRIReco.numContrasts(seq::MESequence)\nMRIReco.echoTimes(seq::MESequence)\nMRIReco.flipAngles(seq::MESequence)\nMRIReco.echoAmplitudes(seq::MESequence, R1::Float64, R2::Float64, numStates=nothing)\nMRIReco.epgAmplitudes(seq::MESequence, R1::Real, R2::Real, numStates=nothing)\nMRIReco.epgRotation\nMRIReco.epgRelaxation\nMRIReco.epgDephasing\nMRIReco.rfRotation","category":"page"},{"location":"API/#Sampling","page":"API","title":"Sampling","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"MRIReco.sample\nMRIReco.sample_kspace(data::AbstractArray,redFac::Float64,patFunc::AbstractString;kargs...)\nMRIReco.sample_kspace(acqData::AcquisitionData,redFac::Float64,\n                       patFunc::AbstractString; rand=true, profiles=true,\n                       seed = 1234, kargs...)\nMRIReco.sample_regular(shape::Tuple, redFac::Float64; kargs...)\nMRIReco.sample_random(shape::Tuple{Int64,Int64},redFac::Float64;calsize::Int64=0,kargs...)\nMRIReco.sample_poissondisk(shape::Tuple{Int64,Int64},redFac::Float64;calsize::Int64=0, seed::Int64=1234,kargs...)\nMRIReco.sample_vdpoisson(shape::Tuple{Int64,Int64},redFac::Float64; seed::Int64=1234,kargs...)\nMRIReco.sample_lines(shape::Tuple{Int64,Int64},redFac::Float64;sampleFunc=\"random\",kargs...)\nMRIReco.calculateIncoherence(acqData::AcquisitionData, recoParams::Dict, slice=1)","category":"page"},{"location":"API/#Simulation","page":"API","title":"Simulation","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"MRIReco.simulation(image::Array{T,3}, simParams::Dict) where T<:Union{ComplexF64,Float64}\nMRIReco.simulation(image::Array{T,3}, simParams::Dict, filename::String;\n                        force=false) where T<:Union{ComplexF64,Float64}\nMRIReco.simulation(image::Array{T,2}, simParams::Dict) where T<:Union{ComplexF64,Float64}\nMRIReco.simulation(tr::Trajectory\n                    , image::Array{ComplexF64}\n                    , correctionMap = []\n                    ; opName=\"fast\"\n                    , senseMaps=[]\n                    , verbose=true\n                    , kargs...)\nMRIReco.simulation(seq::AbstractSequence, tr::Vector{Trajectory}\n                    , image::Array{ComplexF64,3}\n                    ; opName=\"fast\"\n                    , r1map=[]\n                    , r2map=[]\n                    , fmap=[]\n                    , senseMaps=[]\n                    , verbose=true\n                    , kargs...)\nMRIReco.addNoise(x::Vector, snr::Float64, complex= true)\nMRIReco.addNoise(acqData::AcquisitionData, snr::Float64)\nMRIReco.addNoise!(acqData::AcquisitionData, snr::Float64)\nMRIReco.birdcageSensitivity\nMRIReco.measured2DSensitivity\nMRIReco.quadraticFieldmap","category":"page"},{"location":"API/#Reconstruction","page":"API","title":"Reconstruction","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"MRIReco.reconstruction(acqData::AcquisitionData, recoParams::Dict)\nMRIReco.reconstruction(acqData::AcquisitionData, recoParams::Dict, filename::String;force=false)\nMRIReco.setupIterativeReco\nMRIReco.reconstruction_direct_2d\nMRIReco.reconstruction_direct_3d\nMRIReco.reconstruction_simple\nMRIReco.reconstruction_multiEcho\nMRIReco.reconstruction_multiCoil\nMRIReco.reconstruction_multiCoilMultiEcho\nMRIReco.espirit\nMRIReco.nrmsd","category":"page"},{"location":"API/#MRIReco.reconstruction-Tuple{AcquisitionData, Dict}","page":"API","title":"MRIReco.reconstruction","text":"reconstruction(acqData::AcquisitionData, recoParams::Dict)\n\nPerforms image reconstruction of an AcquisitionData object. Parameters are specified in a dictionary.\n\nReconstruction types are specified by the symbol :reco. Valid reconstruction names are:\n\n:direct - direct Fourier reconstruction\n:standard           - iterative reconstruction for all contrasts, coils & slices independently\n:multiEcho          - iterative joint reconstruction of all echo images\n:multiCoil          - SENSE-type iterative reconstruction\n:multiCoilMultiEcho - SENSE-type iterative reconstruction of all echo images\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.reconstruction-Tuple{AcquisitionData, Dict, String}","page":"API","title":"MRIReco.reconstruction","text":"reconstruction(acqData::AcquisitionData, recoParams::Dict,filename::String; force=false)\n\nperforms the same image reconstrucion as reconstruction(acqData::AcquisitionData, recoParams::Dict) and saves the image in a file with name filename. If force=false, the reconstructed image is loaded from the the file filename if the latter is present.\n\n\n\n\n\n","category":"method"},{"location":"API/#MRIReco.reconstruction_simple","page":"API","title":"MRIReco.reconstruction_simple","text":"Performs iterative image reconstruction independently for the data of all coils, contrasts and slices\n\nArguments\n\nacqData::AcquisitionData            - AcquisitionData object\nreconSize::NTuple{2,Int64}              - size of image to reconstruct\nreg::Vector{<:AbstractRegularization}                 - Regularization to be used\nsparseTrafo::AbstractLinearOperator - sparsifying transformation\nweights::Vector{Vector{Complex{<:AbstractFloat}}} - sampling density of the trajectories in acqData\nsolver::Type{<:AbstractLinearSolver}                  - name of the solver to use\n(normalize::Bool=false)             - adjust regularization parameter according to the size of k-space data\n(params::Dict{Symbol,Any})          - Dict with additional parameters\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.reconstruction_multiEcho","page":"API","title":"MRIReco.reconstruction_multiEcho","text":"Performs a iterative image reconstruction jointly for all contrasts. Different slices and coil images are reconstructed independently.\n\nArguments\n\nacqData::AcquisitionData            - AcquisitionData object\nreconSize::NTuple{2,Int64}              - size of image to reconstruct\nreg::Vector{<:AbstractRegularization}                 - Regularization to be used\nsparseTrafo::AbstractLinearOperator - sparsifying transformation\nweights::Vector{Vector{Complex{<:AbstractFloat}}} - sampling density of the trajectories in acqData\nsolver::Type{<:AbstractLinearSolver}                  - name of the solver to use\n(normalize::Bool=false)             - adjust regularization parameter according to the size of k-space data\n(params::Dict{Symbol,Any})          - Dict with additional parameters\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.reconstruction_multiCoil","page":"API","title":"MRIReco.reconstruction_multiCoil","text":"Performs a SENSE-type iterative image reconstruction. Different slices and contrasts images are reconstructed independently.\n\nArguments\n\nacqData::AcquisitionData            - AcquisitionData object\nreconSize::NTuple{2,Int64}              - size of image to reconstruct\nreg::Vector{<:AbstractRegularization}                 - Regularization to be used\nsparseTrafo::AbstractLinearOperator - sparsifying transformation\nweights::Vector{Vector{Complex{<:AbstractFloat}}} - sampling density of the trajectories in acqData\nL_inv::Array{Complex{<:AbstractFloat}}        - noise decorrelation matrix\nsolver::Type{<:AbstractLinearSolver}                  - name of the solver to use\nsenseMaps::AbstractArray{Complex{<:AbstractFloat}}        - coil sensitivities\n(normalize::Bool=false)             - adjust regularization parameter according to the size of k-space data\n(params::Dict{Symbol,Any})          - Dict with additional parameters\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.reconstruction_multiCoilMultiEcho","page":"API","title":"MRIReco.reconstruction_multiCoilMultiEcho","text":"Performs a SENSE-type iterative image reconstruction which reconstructs all contrasts jointly. Different slices are reconstructed independently.\n\nArguments\n\nacqData::AcquisitionData            - AcquisitionData object\nreconSize::NTuple{2,Int64}              - size of image to reconstruct\nreg::Vector{<:AbstractRegularization}                 - Regularization to be used\nsparseTrafo::AbstractLinearOperator - sparsifying transformation\nweights::Vector{Vector{Complex{<:AbstractFloat}}} - sampling density of the trajectories in acqData\nsolver::Type{<:AbstractLinearSolver}                  - name of the solver to use\nsenseMaps::AbstractArray{Complex{<:AbstractFloat}}        - coil sensitivities\n(normalize::Bool=false)             - adjust regularization parameter according to the size of k-space data\n(params::Dict{Symbol,Any})          - Dict with additional parameters\n\n\n\n\n\n","category":"function"},{"location":"API/#MRIReco.nrmsd","page":"API","title":"MRIReco.nrmsd","text":"nrmsd(I,Ireco)\n\ncomputes the normalized root mean squared error of the image Ireco with respect to the image I.\n\n\n\n\n\n","category":"function"},{"location":"operators/#Imaging-Operators","page":"Imaging Operators","title":"Imaging Operators","text":"","category":"section"},{"location":"operators/","page":"Imaging Operators","title":"Imaging Operators","text":"The mapping between the proton density and the recorded signal is linear in MRI and can be described in the continuous case as an integral equation and in the discrete case as a matrix vector multiplication.","category":"page"},{"location":"operators/","page":"Imaging Operators","title":"Imaging Operators","text":"Depending on the imaging scenario, the MRI system matrix can have various different forms. It may encode a Cartesian, or a spiral trajectory. It may take offresonance into account, and it may also encode the sensitivity of the receive coil.","category":"page"},{"location":"operators/","page":"Imaging Operators","title":"Imaging Operators","text":"MRIReco implements various MRI imaging operators. In all cases, the operators have a dedicated Julia type that acts as a matrix. The operator E thus can be applied to a vector x by calling E*x. Similarly, the adjoint can be applied by adjoint(E)*x. We note at this point that the adjoint operation is lazy in Julia and thus the matrix adjoint(E) is never explicitly arranged.","category":"page"},{"location":"operators/","page":"Imaging Operators","title":"Imaging Operators","text":"MRIReco currently implements the following operators:","category":"page"},{"location":"operators/","page":"Imaging Operators","title":"Imaging Operators","text":"FFTOp: A multidimensional FFT operator\nNFFTOp: A multidimensional operator for non-equidistant FFTs\nFieldmapNFFTOp: An operator that takes complex correction terms into account\nSensitivityMapOp: An operator for building a SENSE reconstruction. Has to be combined with one of the former encoding operators\nSamplingOp: An operator that describes the (sub)sampling of full trajectories. The operator is used for Compressed Sensing reconstruction\nWaveletOp: A multidimensional operator for applying Wavelet transformations","category":"page"},{"location":"operators/","page":"Imaging Operators","title":"Imaging Operators","text":"Each of these operators can be build by calling the corresponding constructor. Alternatively one can use the EncodingOp constructor that allows for high-level construction of the imaging operator.","category":"page"},{"location":"SENSE/#Parallel-Imaging","page":"Parallel Imaging","title":"Parallel Imaging","text":"","category":"section"},{"location":"SENSE/","page":"Parallel Imaging","title":"Parallel Imaging","text":"For parallel imaging MRIReco.jl uses an iterative SENSE approach. In the following code example we show how to simulate MRI data with an array of 8 coils and how to reconstruct that data using SENSE. The example can be run by entering","category":"page"},{"location":"SENSE/","page":"Parallel Imaging","title":"Parallel Imaging","text":"include(joinpath(dirname(pathof(MRIReco)),\"../docs/src/examples/exampleSENSE.jl\"))","category":"page"},{"location":"SENSE/","page":"Parallel Imaging","title":"Parallel Imaging","text":"into the Julia REPL.","category":"page"},{"location":"SENSE/","page":"Parallel Imaging","title":"Parallel Imaging","text":"N = 256\nnumCoils = 8\nI = shepp_logan(N)\nI = circularShutterFreq!(I,1)\n\ncoilsens = birdcageSensitivity(N, 8, 1.5)\n\n# simulation parameters\nparams = Dict{Symbol, Any}()\nparams[:simulation] = \"fast\"\nparams[:trajName] = \"Spiral\"\nparams[:numProfiles] = 6\nparams[:numSamplingPerProfile] = div(N*N,16)\nparams[:windings] = div(N,16)\nparams[:AQ] = 2.0e-2\nparams[:senseMaps] = coilsens\n\n# do simulation\nacqData = simulation(I, params)\n\n# reco parameters\nparams = Dict{Symbol, Any}()\nparams[:reco] = \"multiCoil\"\nparams[:reconSize] = (N,N)\nparams[:reg] = L2Regularization(1.e-3)\nparams[:iterations] = 40\nparams[:solver] = CGNR\nparams[:senseMaps] = coilsens\n\n# do reconstruction\nIreco = reconstruction(acqData, params)\n","category":"page"},{"location":"SENSE/","page":"Parallel Imaging","title":"Parallel Imaging","text":"Below one can see the orignal phantom on the left and the reconstruction on the right:","category":"page"},{"location":"SENSE/","page":"Parallel Imaging","title":"Parallel Imaging","text":"(Image: Phantom) (Image: Reconstruction)","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"As outlined in the introduction MRIReco.jl MRIReco has the philosophy to to reuse functionality provided by other Julia package and basically add the MRI specific functionality. This approach is enabled by the Julia package manager that can handle all dependencies automatically. Packages are therefore considered to be cheap in Julia so that modularization can be done across packages. In the following graph, the most important (not all) dependencies of MRIReco are visualized.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: Dependencies)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Most importantly, all iterative solvers are implemented in RegularizedLeastSquares.jl so that MRIReco can benefit from all improvements made in that package. Gridding is implemented in the NFFT.jl package, which has many applications beyond MRI. Sparsifying transformations are usually also not MRI specific and therefore implemented in independent packages (e.g. Wavelets.jl). For storing image data MRIReco.jl uses NiFTI.jl. Dicom data can potentially be saved by the DICOM.jl package, which, however, is not a hard dependency of MRIReco.","category":"page"},{"location":"overview/#Data-Types-and-Flow","page":"Overview","title":"Data Types and Flow","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"An overview about the most important data types and the data flow during recosntruction is given in the following figure.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: DataFlow)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Raw data is usually obtained from files (discussed in File Handling). Since the data layout of the RawAcquisitionData object is not perfectly suited for reconstruction, we  ","category":"page"},{"location":"#MRIReco.jl","page":"Home","title":"MRIReco.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Magnetic Resonance Imaging Reconstruction","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MRIReco is a Julia packet for magnetic resonance imaging. It contains algorithms for the simulation and reconstruction of MRT data and is both easy to use and flexibly expandable.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Both direct and iterative methods are available for image reconstruction. In particular, modern compressed sensing algorithms such as ADMM can be used.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The MRT imaging operator can be set up for a variety of scanning patterns (cartesian, spiral, radial, ...) and can take into account field inhomogeneity as well as the use of coil arrays. The operator can be quickly evaluated using NFFT-based methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"One strength of the package is that it is strongly modular and uses high quality Julia packages. These are e.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"NFFT.jl and FFTW.jl for fast Fourier transformations\nWavelets.jl for sparsification\nLinearOperators.jl in order to be able to divide the imaging operator modularly into individual parts\nRegularizedLeastSquares.jl for modern algorithms for solving linear optimization problems","category":"page"},{"location":"","page":"Home","title":"Home","text":"This interaction allows new algorithms to be easily integrated into the software framework. It is not necessary to program in C/C++ but the advantages of the scientific high-level language Julia can be used.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Start julia and open the package mode by entering ]. Then enter","category":"page"},{"location":"","page":"Home","title":"Home","text":"add MRIReco","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install MRIReco and all its dependencies. If you want to develop MRIReco itself you can checkout MRIReco by calling","category":"page"},{"location":"","page":"Home","title":"Home","text":"dev MRIReco","category":"page"},{"location":"","page":"Home","title":"Home","text":"More information on how to develop a package can be found in the Julia documentation.","category":"page"},{"location":"#Plotting","page":"Home","title":"Plotting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"On purpose MRIReco is not depending on a particular plotting package since there are various plotting packages in the Julia ecosystem. Within the examples outlined in the tutorial we will use PyPlot for plotting but you may prefer using the Plots package. You can add both packages the same way MRIReco has been added.","category":"page"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There is a Jupyter-based tutorial on MRIReco at","category":"page"},{"location":"","page":"Home","title":"Home","text":"https://github.com/MagneticResonanceImaging/MRIRecoTutorial","category":"page"},{"location":"","page":"Home","title":"Home","text":"that has been presented at the ISMRM conference in Montreal 2019. Since the API has slightly changed, we, however recommend that you read this documentation and in particular execute the example scripts as is described in the Getting Started section.","category":"page"},{"location":"filehandling/#File-Handling","page":"File Handling","title":"File Handling","text":"","category":"section"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"MRI Acquisition Data can not only be generated from simulation but also from files. Currently, MRIReco supports the ISMRMRD file format the Bruker file format (at least partially).","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"The ISMRMRD is fully supported with proper read and write support. For the Bruker file format only reading of data is supported.","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"The example discussed in the following can be run by entering","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"include(joinpath(dirname(pathof(MRIReco)),\"../docs/src/examples/exampleIO.jl\"))","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"into the Julia REPL.","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"We start by loading a file handle to a Bruker dataset using","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"f = BrukerFile(\"brukerfileCart\")","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"This file handle does not yet contain the data. To load the data we call","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"raw = RawAcquisitionData(f)","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"which will load all data that can be encoded into a RawAcquisitionData object. For reconstruction we can then convert it to the preprocessed data format and call","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"acq = AcquisitionData(raw)\n\nparams = Dict{Symbol, Any}()\nparams[:reco] = \"direct\"\nparams[:reconSize] = (acq.encodingSize[1],acq.encodingSize[2])\n\nimg = reconstruction(acq, params)","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"This will result in the following image:","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"(Image: BrukerReco)","category":"page"},{"location":"filehandling/#Saving","page":"File Handling","title":"Saving","text":"","category":"section"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"But loading the data is only one important operation. Lets suppose that you have performed an expensive simulation resulting in a raw data object raw. To store this data one can simply run","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"fout = ISMRMRDFile(\"outputfile.h5\")\nsave(fout, raw)","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"which will generate an ISMRMRD file containing the data.","category":"page"},{"location":"filehandling/#Conversion","page":"File Handling","title":"Conversion","text":"","category":"section"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"It should now be no surprise that MRIReco.jl does also allow for file conversion:","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"f = BrukerFile(\"brukerfileCart\")\nraw = RawAcquisitionData(f)\nfout = ISMRMRDFile(\"outputfile.h5\")\nsave(fout, raw)","category":"page"},{"location":"filehandling/","page":"File Handling","title":"File Handling","text":"Currently, this is only limited to converting Bruker files into ISMRMRD files but the infrastructure is not limited to that.","category":"page"}]
}
